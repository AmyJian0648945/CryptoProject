//! 
//# c6748.cdb 5.25.36

object CACHE_L2 :: MEM {
    param iComment :: "Do not delete, in use by cache"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "USER"
    param iDelMsg :: "ok"
    param base :: 293863424
    param len :: 0
    param iAllocHeap :: 0
    param iHeapSize :: 32768
    param iUserHeapId :: 0
    param iHeapId :: @segment_name
    param iReqHeapCount :: 0
    param space :: "Cache"
    param dynamicLoading :: 0
    param iIsModifiable :: 1
}

object CACHE_L1P :: MEM {
    param iComment :: "Do not delete, in use by cache"
    param iIsUsed :: 1
    param iId :: 0
    param iDelUser :: "USER"
    param iDelMsg :: "ok"
    param base :: 299892736
    param len :: 32768
    param iAllocHeap :: 0
    param iHeapSize :: 32768
    param iUserHeapId :: 0
    param iHeapId :: @segment_name
    param iReqHeapCount :: 0
    param space :: "Cache"
    param dynamicLoading :: 0
    param iIsModifiable :: 1
}

object CACHE_L1D :: MEM {
    param iComment :: "Do not delete, in use by cache"
    param iIsUsed :: 1
    param iId :: 0
    param iDelUser :: "USER"
    param iDelMsg :: "ok"
    param base :: 300941312
    param len :: 32768
    param iAllocHeap :: 0
    param iHeapSize :: 32768
    param iUserHeapId :: 0
    param iHeapId :: @segment_name
    param iReqHeapCount :: 0
    param space :: "Cache"
    param dynamicLoading :: 0
    param iIsModifiable :: 1
}

class Module {
    prop Visible :: 1
    prop Writable :: 1
    prop IsConfMod :: (if self.gNumOf > 0 {1} else {0})
    prop NoGen :: 0
    prop IsDirty :: ($a = self.gDirty, self.gDirty = 0, $a)
    prop dataSize :: 0
    prop error :: # ("Error: ", self.name, $1)
    prop warning :: ("Warning ...", self.name, $1)
    prop minBit :: ($a = 0, while (($1 & (1 << $a)) && $a < 32) {++$a}, $a)
    prop name :: ("<unnamed module>")
    prop numBit :: ($a = $b = 0, while ($a < 32) {if ($1 & (1 << $a)) {++$b} }, $b)
}

class ObjectMgr {
    isa Module
    prop CanCreate :: (if (self.gNumOf < self.maxObjs()) {self.localCanCreate()} else {self.warning("Maximum number of objects already created")})
    prop CanDelete :: (if (self.iDelMsg == "ok" || (self.iDelUser == self.gUser)) {if (self.iId >= 0 && self.iIsUsed) {self.localCanDelete()} else {self.warning("Object already deleted")}} else {self.warning(self.iDelMsg)})
    prop Create :: ((self.gUser = (if $0 > 0 {$1} else {"USER"})), if (($a = self.CanCreate()) == "ok") {if (($a = self.localCreate()) == "ok") {if (self.iIsUsed == 0) {self.mkId(if $0 > 1 {$2} else {-1}), self.iIsUsed = 1, GlobalStatus.gDirty = 1, self.gDirty = 1} } } , (self.gUser = "USER"), $a)
    prop Delete :: ((self.gUser = (if $0 > 0 {$1} else {"USER"})), if (($a = self.CanDelete()) == "ok") {if (($a = self.localDelete()) == "ok") {self.rmId(self.iId), self.iIsUsed = 0, GlobalStatus.gDirty = 1, self.gDirty = 1} } , (self.gUser = "USER"), $a)
    prop GetSetOf :: (self.gSetOf)
    prop GetNumOf :: (self.gNumOf)
    prop GetObjId :: (self.iId)
    prop GetPriority :: (self.iId)
    prop SetPriority :: (self.iId = $1)
    prop IsConfObj :: (self.iIsUsed)
    prop localCanCreate :: ("ok")
    prop localCanDelete :: ("ok")
    prop localCreate :: ("ok")
    prop localDelete :: ("ok")
    prop localInit :: (0)
    prop isFinite :: (if self.maxObjs() <= GBL.DSPWORDSIZE {1} else {0})
    prop mkId :: (if (self.isFinite()) {if ($1 < 0) {self.iId = self.minBit(self.gSetOf)} else {self.iId = $1}, (self.gSetOf |= (1 << self.iId))} else {self.iId = 0}, ++self.gNumOf, self.iId)
    prop rmId :: (if (self.isFinite()) {self.gSetOf &= ~(1 << self.iId)} , --self.gNumOf)
    prop maxObjs :: (GBL.DSPWORDSIZE)
    prop isDriver :: (0)
    prop SortChildHierView :: (1)
}

type GlobalStatus {
    prop NoGen :: 1
    prop Visible :: 0
    prop Writable :: 0
    prop Label :: "Current Configuration Status"
    prop GlobalIcon :: 101
    prop InstanceIcon :: 101
    prop GlobalHelpTopic :: (100)
    prop GlobalPropertyPage :: ("{9D3AD931-847B-11d0-A621-0000C070F3E9}")
    prop Status :: (# self.SeedVersion, # self.MinStackSize, # self.SysDataSize)
    global GENLIB :: "bioscfg.dll" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Generation Library"
        prop NoGen :: 1
        prop Visible :: 0
        prop Writable :: 1
    }
    global DATE :: "Fri May 12 15:25:11 2017" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global GCONFVERS :: "@(#)*** xdcutils-g02" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global SysDataSize :: = ($a = 0, scan ($i; nil) {if ($i.dataSize() != nil) {$a = $a + $i.dataSize()} }, $a) { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "Estimated Data Size: %d"
        prop StatusField :: 1
        prop NoGen :: 1
    }
    global MinStackSize :: = ($a = ((2 * (2)) * 4), $a = $a + ((2 * (5)) * 4), $a = $a + ((0) * 4), $b = 0, scan ($i; CLK) {if ($i.IsConfObj()) {$b |= 1} }, $a = $a + (((2 * (2)) * 4) * $b), $b = 0, scan ($i; HWI) {if ($i.IsConfObj()) {if ($i != HWI_NMI && $i != HWI_RESET) {if (($i.function != @HWI_unused) && ($i.function != @RESERVED)) {$b++} } } }, $a = $a + (((12 + 14 + 2) * 4) * $b), $b = 0, scan ($i; SWI) {if ($i.IsConfObj()) {if ($i.priority > $b) {$b = $i.priority} } }, $a = $a + ((((2 * 2) + 18 + (2 * 4)) * 4) * $b), $b = 0, scan ($i; PRD) {if ($i.IsConfObj()) {$b |= 1} }, $a = $a + (((2 * (3)) * 4) * $b), $a) { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "Est. Min. Stack Size (MAUs): %d"
        prop StatusField :: 1
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global ConfigWarnings :: = (if (self.MinStackSize > MEM.STACKSIZE) {"Application stack size is too small; decrease the number of SWI priorities or increase the stack in MEM."} else {"None"}) { 
        prop Label :: "Warnings"
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global SeedVersion :: = "@(#)*** cuda-u36x" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
}

class EModule {
    isa Module
    prop IsXMod :: (1)
    prop Vendor :: ("")
    prop Version :: ("")
}

class EObjectMgr {
    isa ObjectMgr
    prop IsXMod :: (1)
    prop Vendor :: ("")
    prop Version :: ("")
}

class ModuleFolder {
    isa Module
    prop NoGen :: 1
}

type SYSTEM {
    isa ModuleFolder
    prop Label :: "System"
    prop GlobalIcon :: 151
    prop GlobalHelpTopic :: (500)
    prop GlobalPropertyPage :: ("{B936FB91-52A5-11d4-947C-0050048381B7}")
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
}

type INS {
    isa ModuleFolder
    prop Label :: "Instrumentation"
    prop GlobalIcon :: 152
    prop GlobalHelpTopic :: (501)
    prop GlobalPropertyPage :: ("{053C8F90-52A6-11d4-947C-0050048381B7}")
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
}

type SCH {
    isa ModuleFolder
    prop Label :: "Scheduling"
    prop GlobalIcon :: 153
    prop GlobalHelpTopic :: (502)
    prop GlobalPropertyPage :: ("{053C8F91-52A6-11d4-947C-0050048381B7}")
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
}

type SYN {
    isa ModuleFolder
    prop Label :: "Synchronization"
    prop GlobalIcon :: 154
    prop GlobalHelpTopic :: (503)
    prop GlobalPropertyPage :: ("{053C8F92-52A6-11d4-947C-0050048381B7}")
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
}

type IOF {
    isa ModuleFolder
    prop Label :: "Input/Output"
    prop GlobalIcon :: 155
    prop GlobalHelpTopic :: (504)
    prop GlobalPropertyPage :: ("{053C8F93-52A6-11d4-947C-0050048381B7}")
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
}

type SIODRIVER {
    isa ModuleFolder
    prop Label :: "Device Drivers"
    prop IsContainedIn :: IOF
    prop GlobalIcon :: 127
    prop GlobalHelpTopic :: (505)
    prop GlobalPropertyPage :: ("{A2BCEC70-5365-11d4-947C-0050048381B7}")
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
}

type PROJ {
    isa ObjectMgr
    prop name :: "PROJ"
    prop maxObjs :: 0
    prop Label :: "Project Manager"
    prop GlobalIcon :: 121
    prop InstanceIcon :: 122
    prop InstanceHelpTopic :: (201)
    prop GlobalHelpTopic :: (101)
    prop InstancePropertyPage :: ("{AC3C77D1-890B-11d0-A621-0000C070F3E9}")
    prop GlobalPropertyPage :: ("{AC3C77D2-890B-11d0-A621-0000C070F3E9}")
    prop NoGen :: 1
    prop Visible :: 0
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global ALIASALL :: 1 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Generate C Names for All Objects"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
    }
    global IGNOREWARNING :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Ignore Warnings"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
    }
    global LIBPATH :: ".;../../lib;$(BIOSROOT)/lib" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Library Search Path"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    global INCPATH :: ".;../../include;$(BIOSROOT)/include" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Include File Search Path"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    global OBJDIR :: "." { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Object file directory"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    global EXTEXE :: "out" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Executable File Extension"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    global EXTLIB :: "lib" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Library File Extension"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    global EXTASM :: "asm" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Assembly Language Source File Extension"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    global EXTOBJ :: "obj" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Object File Extension"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iComment :: if self.iDelUser == "USER" {"<add comments here>"} else {self.iDelMsg} { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "comment"
        prop JSName :: "comment"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "USER" {1} else {0}
        prop NoGen :: 1
    }
    inst iIsUsed :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iId :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iDelUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDelMsg :: "ok" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst projType :: "Executable" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Executable,Library"
        prop Label :: "Target Type"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst projName :: "$(PROG)" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Target File Name"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst useRpt :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Use RPT Instruction"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst minimizeSpace :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Optimize for Space over Time"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst tmx :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Avoid TMX Silicon Bugs"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
}

type PROJ_FILE {
    isa ObjectMgr
    prop Visible :: 0
    prop Label :: "Project File Manager"
    prop InstanceHelpTopic :: (BIOSHELP_PROJ_FILE_INSTANCE)
    prop GlobalHelpTopic :: (BIOSHELP_PROJ_FILE_GLOBAL)
    prop InstancePropertyPage :: ("{AC3C77D3-890B-11d0-A621-0000C070F3E9}")
    prop GlobalPropertyPage :: ("{AC3C77D4-890B-11d0-A621-0000C070F3E9}")
    prop NoGen :: 1
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iComment :: if self.iDelUser == "USER" {"<add comments here>"} else {self.iDelMsg} { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "comment"
        prop JSName :: "comment"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "USER" {1} else {0}
        prop NoGen :: 1
    }
    inst iIsUsed :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iId :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iDelUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDelMsg :: "ok" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst elemType :: "C Source" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "C Source,ASM Source,Library,Linker Command File"
        prop Label :: "Input File Type"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst elemName :: "$(PROG)" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Input File Name"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst optLevel :: "register+local+global" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "register,register+local,register+local+global,register+local+global+file"
        prop Label :: "Optimization Level"
        prop Visible :: 0
        prop Writable :: if self.elemType == "C Source" {1} else {0}
        prop NoGen :: 1
    }
    inst inline :: 1 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Inline Expansion"
        prop Visible :: 0
        prop Writable :: if self.elemType == "C Source" {1} else {0}
        prop NoGen :: 1
    }
    inst definitions :: "" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Additional Definitions"
        prop Visible :: 0
        prop Writable :: if self.elemType == "C Source" {1} else {0}
        prop NoGen :: 1
    }
    inst iParent :: 0 { 
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
}

type GBL {
    isa Module
    prop name :: "GBL"
    prop Label :: "Global Settings"
    prop IsContainedIn :: SYSTEM
    prop cGen :: 0
    prop GenLinkPrologue :: ("%10S\nSECTIONS {%4t\n.vers (COPY): {} /* version information */%0t\n}\n\n-priority\n--trampolines\n%26S%1S%22S-l%2S%23S%3S\n%24S%15S%4S%16S%18S%5S%6S%12S%7S%17S%25S%27S%28S%29S%30S\n\0, _autoInitStr, _board, _librarySuffix, _devLibStr, _biosLibStr, _rtdxLibStr, _rtsLibStr, _librarySuffix, _compilerModel, _lnkCmdStr, _lnkCmdFile, _cslLibStr, _chipType, _librarySuffix, _chipStr, _sioLibStr, _mpcLibStr, _bios6xLibStr, _bios6xClkType, _instStr, _rtsNameStr, _romStr, _biosRomStr, _logLibStr, _pwrmLibStr, _SKLibStr, _psclLibStr, _pmiLibStr, _pmiVoltLibStr, _psclCfgLibStr, _pmiVoltControlLibStr, _psclConfigLibStr")
    prop poolStr :: (if (self.LINKWITHROM == 0) {""} else {if POOL.USEPOOL {""} else {"_POOL_config=0;\n"}})
    prop msgqStr :: (if (self.LINKWITHROM == 0) {""} else {if MSGQ.USEMSGQ {""} else {"_MSGQ_config=0;\n"}})
    prop bcacheBootStr :: (if (self.C64PL2CONFIGURE) {if (self.C64PL1PCFG != "32k" || self.C64PL1DCFG != "32k" || self.C64PL2MODEOPTS != "0k") {"_BCACHE_bootInit=_BCACHE_setCacheToSram;\n"} else {"_BCACHE_bootInit=_FXN_F_nop;\n"}} else {"_BCACHE_bootInit=_FXN_F_nop;\n"})
    prop GenLinkEpilogue :: ("%0t_GBL_CACHE = GBL_CACHE;\n%1S%2S%3S\0, poolStr, msgqStr, bcacheBootStr")
    prop ConfigurationClass :: "{2779A121-92CC-11d1-A63D-0000C070F3E9}"
    prop GlobalIcon :: 105
    prop InstanceIcon :: 106
    prop GlobalHelpTopic :: (103)
    prop InstanceHelpTopic :: (103)
    prop InstancePropertyPage :: ("{B7240DE4-AA51-11cf-9BFE-0000C0AC14C7}")
    prop GlobalPropertyPage :: ("{B7240DE5-AA51-11cf-9BFE-0000C0AC14C7}")
    prop localInit :: (RTA_toHost.Create("HST"), RTA_toHost.bufseg = HST.OBJMEMSEG, RTA_fromHost.Create("HST"), RTA_fromHost.bufseg = HST.OBJMEMSEG, RTA_dispatcher.Create("HST"), IDL_busyObj.Create("IDL"), IDL.USEIDLBUSYOBJ = 1, IDL_cpuLoad.Create("IDL"))
    prop chipcall :: ("ok")
    prop IsConfMod :: 1
    prop ucompare :: ($e = "ok", $a = ($1 >> 31) & 0x00000001, $b = ($2 >> 31) & 0x00000001, $c = $1 & 0x7fffffff, $d = $2 & 0x7fffffff, if ($a > $b) {$e = "gt"} else {if ($a == $b) {if ($c > $d) {$e = "gt"} else {if ($c == $d) {$e = "eq"} else {$e = "lt"}}} else {$e = "lt"}}, $e)
    prop L2Check :: (if (self.DSPSUBTYPE == 6211 || self.DSPSUBTYPE == 6711) {self.PCC = "mapped", if (self.C641XL2CONFIGURE == 1) {self.C641XL2CONFIGURE = 0, self.L2CONFIGALLOC = 0} , self.L2CacheSizeCheck()} else {if (self.DSPSUBTYPE == 6400) {self.PCC = "mapped", if (self.C621XL2CONFIGURE == 1) {self.C621XL2CONFIGURE = 0} , self.L2CacheSizeCheck()} else {if (self.C621XL2CONFIGURE == 1) {self.C621XL2CONFIGURE = 0, self.L2CacheSizeCheck()} else {if (self.C641XL2CONFIGURE == 1) {self.C641XL2CONFIGURE = 0, self.L2CONFIGALLOC = 0, self.L2CacheSizeCheck()} }}})
    prop C621xL2CacheSizeCheck :: ($e = "ok", $a = CACHE_L2.base, $b = CACHE_L2.len, if (self.C621XL2CONFIGURE == 0) {CACHE_L2.Delete("MEM")} else {if (self.L2MODEOPTS == "SRAM") {CACHE_L2.base = CACHE_L2.base + CACHE_L2.len, CACHE_L2.len = 0x0, CACHE_L2.Delete("MEM")} else {if (self.L2MODEOPTS == "1-way cache") {CACHE_L2.Create("MEM"), CACHE_L2.base = CACHE_L2.base + CACHE_L2.len - 0x4000, CACHE_L2.len = 0x4000} else {if (self.L2MODEOPTS == "2-way cache") {CACHE_L2.Create("MEM"), CACHE_L2.base = CACHE_L2.base + CACHE_L2.len - 0x8000, CACHE_L2.len = 0x8000} else {if (self.L2MODEOPTS == "3-way cache") {CACHE_L2.Create("MEM"), CACHE_L2.base = CACHE_L2.base + CACHE_L2.len - 0xc000, CACHE_L2.len = 0xc000} else {if (self.L2MODEOPTS == "4-way cache") {CACHE_L2.Create("MEM"), CACHE_L2.base = CACHE_L2.base + CACHE_L2.len - 0x10000, CACHE_L2.len = 0x10000} }}}}}, $e)
    prop C641xL2CacheSizeCheck :: ($e = "ok", $a = CACHE_L2.base, $b = CACHE_L2.len, if (self.C641XL2CONFIGURE == 0) {CACHE_L2.Delete("MEM")} else {if (self.C641XL2MODEOPTS == "4-way cache (0k)") {CACHE_L2.base = CACHE_L2.base + CACHE_L2.len - 0x0, CACHE_L2.len = 0x0, CACHE_L2.Delete("MEM")} else {if (self.C641XL2MODEOPTS == "4-way cache (32k)") {CACHE_L2.Create("MEM"), CACHE_L2.base = CACHE_L2.base + CACHE_L2.len - 0x8000, CACHE_L2.len = 0x8000} else {if (self.C641XL2MODEOPTS == "4-way cache (64k)") {CACHE_L2.Create("MEM"), CACHE_L2.base = CACHE_L2.base + CACHE_L2.len - 0x10000, CACHE_L2.len = 0x10000} else {if (self.C641XL2MODEOPTS == "4-way cache (128k)") {CACHE_L2.Create("MEM"), CACHE_L2.base = CACHE_L2.base + CACHE_L2.len - 0x20000, CACHE_L2.len = 0x20000} else {if (self.C641XL2MODEOPTS == "4-way cache (256k)") {CACHE_L2.Create("MEM"), CACHE_L2.base = CACHE_L2.base + CACHE_L2.len - 0x40000, CACHE_L2.len = 0x40000} }}}}}, $e)
    prop C64PL1PCacheSizeCheck :: ($e = "ok", if (self.C64PL2CONFIGURE == 0) {self.C64PL1PCFG = "32k", CACHE_L1P.Create("MEM"), CACHE_L1P.base = CACHE_L1P.base + CACHE_L1P.len - 0x8000, CACHE_L1P.len = 0x8000} else {if (self.C64PL1PCFG == "0k") {CACHE_L1P.base = CACHE_L1P.base + CACHE_L1P.len - 0x0, CACHE_L1P.len = 0x0, CACHE_L1P.Delete("MEM")} else {if (self.C64PL1PCFG == "4k") {CACHE_L1P.Create("MEM"), CACHE_L1P.base = CACHE_L1P.base + CACHE_L1P.len - 0x1000, CACHE_L1P.len = 0x1000} else {if (self.C64PL1PCFG == "8k") {CACHE_L1P.Create("MEM"), CACHE_L1P.base = CACHE_L1P.base + CACHE_L1P.len - 0x2000, CACHE_L1P.len = 0x2000} else {if (self.C64PL1PCFG == "16k") {CACHE_L1P.Create("MEM"), CACHE_L1P.base = CACHE_L1P.base + CACHE_L1P.len - 0x4000, CACHE_L1P.len = 0x4000} else {if (self.C64PL1PCFG == "32k") {CACHE_L1P.Create("MEM"), CACHE_L1P.base = CACHE_L1P.base + CACHE_L1P.len - 0x8000, CACHE_L1P.len = 0x8000} else {$e = self.error("Unknown cache size")}}}}}}, $e)
    prop C64PL1DCacheSizeCheck :: ($e = "ok", if (self.C64PL2CONFIGURE == 0) {self.C64PL1DCFG = "32k", CACHE_L1D.Create("MEM"), CACHE_L1D.base = CACHE_L1D.base + CACHE_L1D.len - 0x8000, CACHE_L1D.len = 0x8000} else {if (self.C64PL1DCFG == "0k") {CACHE_L1D.base = CACHE_L1D.base + CACHE_L1D.len - 0x0, CACHE_L1D.len = 0x0, CACHE_L1D.Delete("MEM")} else {if (self.C64PL1DCFG == "4k") {CACHE_L1D.Create("MEM"), CACHE_L1D.base = CACHE_L1D.base + CACHE_L1D.len - 0x1000, CACHE_L1D.len = 0x1000} else {if (self.C64PL1DCFG == "8k") {CACHE_L1D.Create("MEM"), CACHE_L1D.base = CACHE_L1D.base + CACHE_L1D.len - 0x2000, CACHE_L1D.len = 0x2000} else {if (self.C64PL1DCFG == "16k") {CACHE_L1D.Create("MEM"), CACHE_L1D.base = CACHE_L1D.base + CACHE_L1D.len - 0x4000, CACHE_L1D.len = 0x4000} else {if (self.C64PL1DCFG == "32k") {CACHE_L1D.Create("MEM"), CACHE_L1D.base = CACHE_L1D.base + CACHE_L1D.len - 0x8000, CACHE_L1D.len = 0x8000} else {$e = self.error("Unknown cache size")}}}}}}, $e)
    prop C64PL2CacheSizeCheck :: ($e = "ok", if (self.C64PL2CONFIGURE == 0) {CACHE_L2.Delete("MEM")} else {if (self.C64PL2MODEOPTS == "0k") {CACHE_L2.base = CACHE_L2.base + CACHE_L2.len - 0x0, CACHE_L2.len = 0x0, CACHE_L2.Delete("MEM")} else {if (self.C64PL2MODEOPTS == "32k") {CACHE_L2.Create("MEM"), CACHE_L2.base = CACHE_L2.base + CACHE_L2.len - 0x8000, CACHE_L2.len = 0x8000} else {if (self.C64PL2MODEOPTS == "64k") {CACHE_L2.Create("MEM"), CACHE_L2.base = CACHE_L2.base + CACHE_L2.len - 0x10000, CACHE_L2.len = 0x10000} else {if (self.C64PL2MODEOPTS == "128k") {CACHE_L2.Create("MEM"), CACHE_L2.base = CACHE_L2.base + CACHE_L2.len - 0x20000, CACHE_L2.len = 0x20000} else {if (self.C64PL2MODEOPTS == "256k") {CACHE_L2.Create("MEM"), CACHE_L2.base = CACHE_L2.base + CACHE_L2.len - 0x40000, CACHE_L2.len = 0x40000} else {if (self.C64PL2MODEOPTS == "512k") {CACHE_L2.Create("MEM"), CACHE_L2.base = CACHE_L2.base + CACHE_L2.len - 0x80000, CACHE_L2.len = 0x80000} else {if (self.C64PL2MODEOPTS == "1024k") {CACHE_L2.Create("MEM"), CACHE_L2.base = CACHE_L2.base + CACHE_L2.len - 0x100000, CACHE_L2.len = 0x100000} else {$e = self.error("Unknown cache size")}}}}}}}}, $e)
    prop L2CacheSizeCheck :: ($e = "ok", scan ($i; MEM) {if ($i == CACHE_L2) {if self.C621XL2CONFIGURE {$e = self.C621xL2CacheSizeCheck()} else {if self.C641XL2CONFIGURE {$e = self.C641xL2CacheSizeCheck()} else {if self.DSPSUBTYPE == 6211 || self.DSPSUBTYPE == 6711 {$e = self.C621xL2CacheSizeCheck()} else {if self.DSPSUBTYPE == 6400 {$e = self.C641xL2CacheSizeCheck()} else {{CACHE_L2.base = 0x0, CACHE_L2.len = 0x0, CACHE_L2.Delete("MEM")}}}}}} }, $e)
    prop setCPUClock :: ($e = "ok", if ($1 != self.CPUCLOCK) {$a = self.CPUCLOCK, self.CPUCLOCK = $1, if (GBL.CALLBACKOBJ != nil) {$e = GBL.CALLBACKOBJ.call()} , if ($e != "ok") {self.CPUCLOCK = $a, GBL.CALLBACKOBJ.call()} } , if ($e == "ok") {"ok"} else {self.error($e)})
    prop setL1PMODE :: (if self.C64PL1PCFG == "0k" {0x0} else {if self.C64PL1PCFG == "4k" {0x1} else {if self.C64PL1PCFG == "8k" {0x2} else {if self.C64PL1PCFG == "16k" {0x3} else {0x7}}}})
    prop setL1DMODE :: (if self.C64PL1DCFG == "0k" {0x0} else {if self.C64PL1DCFG == "4k" {0x1} else {if self.C64PL1DCFG == "8k" {0x2} else {if self.C64PL1DCFG == "16k" {0x3} else {0x7}}}})
    prop setL2MODE :: (if self.C64PL2MODEOPTS == "0k" {0x0} else {if self.C64PL2MODEOPTS == "32k" {0x1} else {if self.C64PL2MODEOPTS == "64k" {0x2} else {if self.C64PL2MODEOPTS == "128k" {0x3} else {if self.C64PL2MODEOPTS == "256k" {0x4} else {if self.C64PL2MODEOPTS == "512k" {0x5} else {if self.C64PL2MODEOPTS == "1024k" {0x6} else {0x7}}}}}}})
    prop _cint00Str :: "-u_c_int00 %24t/* link with alternate boot.obj */%0t\n"
    prop _autoInitStr :: ""
    prop _board :: (if (HST.RTDX == 1) {"lnkrtdx"} else {if (HST.DSM == 1) {"lnkdsm"} else {if (HST.EVM54 == 1) {"lnkevm54"} else {if (HST.BIOSLINK == 1) {"lnkbioslink"} else {"lnknone"}}}})
    prop _dsptype :: GBL.DSPTYPE
    prop _instStr :: if self.INSTRUMENTED {""} else {"_NONINST"}
    prop _rtsNameStr :: (self.RTSLIB)
    prop _biosLibStr :: "-lbios%20S%23S%8S %24t/* DSP/BIOS support */%0t\n"
    prop _compilerModel :: if self.ENDIAN == "big" {"e"} else {""}
    prop _librarySuffix :: (if (self.DSPSUBTYPE == 6700 || self.DSPSUBTYPE == 6711 || self.DSPSUBTYPE == 6712 || self.DSPSUBTYPE == 6713) {if (self.ENDIAN == "big") {".a67e"} else {".a67"}} else {if (self.DSPSUBTYPE == 6400) {if (self.ENDIAN == "big") {".a64e"} else {".a64"}} else {if (self.DSPSUBTYPE == 6499) {if (self.ENDIAN == "big") {".a64Pe"} else {".a64P"}} else {if (self.DSPSUBTYPE == 6799) {if (self.ENDIAN == "big") {".a67Pe"} else {".a67P"}} else {if ((self.DSPSUBTYPE == 6747) || (self.DSPSUBTYPE == 6748)) {if (self.ENDIAN == "big") {".a674e"} else {".a674"}} else {if (self.ENDIAN == "big") {".a62e"} else {".a62"}}}}}})
    prop _rtdxLibStr :: if RTDX.USERTDX == 0 {""} else {if RTDX.RTDXTYPE == "JTAG" {"-lrtdx64xplus%9S.lib %24t/* RTDX support */%0t\n"} else {if RTDX.RTDXTYPE == "Simulator" {"-lrtdxsim%9S.lib %24t/* RTDX support */%0t\n"} else {"-lrtdx64xplushs%9S.lib %24t/* RTDX support */%0t\n"}}}
    prop _rtsLibStr :: (if self.SPECIFYRTSLIB {"-l%21S%24t/* C and C++ run-time library support */%0t\n"} else {if self.DSPSUBTYPE == 6700 || self.DSPSUBTYPE == 6711 || self.DSPSUBTYPE == 6712 || self.DSPSUBTYPE == 6713 {"-lrts6700%9S.lib%24t/* C and C++ run-time library support */%0t\n"} else {if self.DSPSUBTYPE == 6400 {"-lrts6400%9S.lib%24t/* C and C++ run-time library support */%0t\n"} else {if self.DSPSUBTYPE == 6799 {"-lrts67plus%9S.lib%24t/* C and C++ run-time library support */%0t\n"} else {if self.DSPSUBTYPE == 6499 {"-lrts64plus%9S.lib%24t/* C and C++ run-time library support */%0t\n"} else {if ((self.DSPSUBTYPE == 6747) || (self.DSPSUBTYPE == 6748)) {"-lrts6740%9S.lib%24t/* C and C++ run-time library support */%0t\n"} else {"-lrts6200%9S.lib%24t/* C and C++ run-time library support */%0t\n"}}}}}})
    prop _bios6xClkType :: (if self.CLKTYPE == 6000 {"C6000"} else {if self.CLKTYPE == 700 {"DA700"} else {if (self.CLKTYPE == 420 || self.CLKTYPE == 6424) {if self.USEIDMA0DISPATCHER {"DM420IDMA0"} else {"DM420"}} else {if self.CLKTYPE == 2430 {"2430"} else {if self.CLKTYPE == 6482 {"TCI6482"} else {if self.CLKTYPE == 6486 {"TCI6486"} else {if self.CLKTYPE == 6488 {"TCI6488"} else {if self.CLKTYPE == 442 {"DRA442"} else {if self.CLKTYPE == 3430 {"3430"} else {if self.CLKTYPE == 6467 {"DM6467"} else {if self.CLKTYPE == 761990 {"F761990"} else {if self.CLKTYPE == 6747 {"6748"} else {""}}}}}}}}}}}})
    prop _bios6xLibStr :: ("-lbios%19S%23S%8S%24t/* BIOS clock specific library */%0t\n")
    prop _chipStr :: ""
    prop _pwrmLibStr :: if PWRM.PWRM_ENABLE == 1 {"-lpwrm.a674"} else {""}
    prop _pmiLibStr :: if PWRM.PWRM_ENABLE == 1 {"\n-lpmi.a674"} else {""}
    prop _pmiVoltLibStr :: if (PWRM.PWRM_ENABLE == 1) {if (PWRM.PWRM_SCALING == 1) {"\n-l%31S"} else {"\n-lpmi_ctl_null.a674"}} else {""}
    prop _pmiVoltControlLibStr :: PWRM.PWRM_PMILIB
    prop _psclLibStr :: if (PWRM.PWRM_ENABLE == 1) {if (PWRM.PWRM_SCALING == 1) {"\n-lpscl.a674"} else {"\n-lpsclnull.a674"}} else {""}
    prop _psclCfgLibStr :: if (PWRM.PWRM_ENABLE == 1) && (PWRM.PWRM_SCALING == 1) {"\n-l%32S"} else {""}
    prop _psclConfigLibStr :: PWRM.PWRM_CONFIGLIB
    prop _mpcLibStr :: ""
    prop _lnkCmdFile :: MEM.LNKCMDFILE
    prop _lnkCmdStr :: (if (MEM.LNKCMDFILE == "") {""} else {"-l%11S %24t/* User Specified Linker cmd file */%0t\n"})
    prop _sioLibStr :: if SIO.USEISSUERECLAIM == 1 {"-lsioir%23S%8S %24t/* supports SIO Issue/Reclaim model only */%0t\n"} else {"-lsioboth%23S%8S %24t/* supports both SIO models */%0t\n"}
    prop _devLibStr :: "-ldrivers%23S%14S %24t/* device drivers support */%0t\n"
    prop _cslLibStr :: ""
    prop _chipType :: ""
    prop _logLibStr :: if LOG.TS {"-llog8%3S\n"} else {""}
    prop _romStr :: if self.LINKWITHROM {"-lromC672x.out\n-lromC672x.cmd\n"} else {""}
    prop _biosRomStr :: if self.LINKWITHROM {"_BIOSROM"} else {""}
    prop _SKLibStr :: if self.ENABLE_SK {"-lbiosSK%3S\n"} else {""}
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global PRODUCT :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop NoGen :: 1
        prop Visible :: 0
        prop Writable :: 1
        prop EnvField :: 1
    }
    global CALLBACKOBJ :: CLK { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global CHIPCHAIN :: nil { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global TRACE :: "CD-01234567" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Trace Mask"
        prop NoGen :: 1
        prop Visible :: 0
        prop Writable :: 0
    }
    global BOARD :: "c6748" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Target Board Name"
        prop JSName :: "BOARDNAME"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
    }
    global ROM :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Link to ROM Library"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    global CPUCLOCK :: 300.000000 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global PROCID :: = 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Label :: "Processor ID (PROCID)"
        prop JSName :: "PROCID"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
    }
    global CLKIN :: = 20000 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x20
        prop Label :: "Board Clock in KHz (Informational Only)"
        prop JSName :: "CLKIN"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
    }
    global FREQ :: 300000 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x20
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    global MIPS :: 300.000000 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Style :: 0x04
        prop Format :: "%.4f"
        prop Label :: "DSP Speed In MHz (CLKOUT)"
        prop JSName :: "CLKOUT"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
        prop Set :: ($a = self.MIPS, $b = if (GBL.DSPTYPE == 62) {$1} else {$1 * 2}, $e = "ok", self.MIPS = $1, self.FREQ = int(self.MIPS * 1000), if (($e = self.setCPUClock($b)) != "ok") {self.MIPS = $a} , $e)
    }
    global OSTYPE :: "BIOS" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "BIOS"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global DSPTYPE :: 62 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "DSP Major Type"
        prop JSName :: "DSPTYPE"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    global SPECIFYRTSLIB :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Specify RTS library"
        prop JSName :: "SPECIFYRTSLIB"
        prop NoGen :: 1
        prop Visible :: 1
        prop Writable :: 1
    }
    global RTSLIB :: "" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Run-Time Support Library"
        prop JSName :: "RTSLIB"
        prop NoGen :: 1
        prop Visible :: 1
        prop Writable :: self.SPECIFYRTSLIB
    }
    global DSPSUBTYPE :: 6748 { 
        prop Type :: "{A11FE980-C07A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "6748"
        prop Label :: "DSP Type"
        prop Visible :: 0
        prop Writable :: 1
        prop Set :: (self.DSPSUBTYPE = $1, self.L2Check(), "ok")
        prop NoGen :: 0
    }
    global CLKTYPE :: 6747 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "CLK Type"
        prop JSName :: "CLKTYPE"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 0
    }
    global CHIPTYPE :: "other" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "custom,other"
        prop Label :: "Chip Support Library (CSL)"
        prop JSName :: "CHIPTYPE"
        prop NoGen :: 1
        prop Visible :: 0
        prop Writable :: 1
        prop Set :: (if ($1 == "6201" || $1 == "6202" || $1 == "6203" || $1 == "6204" || $1 == "6205") {self.DSPSUBTYPE = 6200} else {if ($1 == "6701") {self.DSPSUBTYPE = 6700} else {if ($1 == "6211") {self.DSPSUBTYPE = 6211} else {if ($1 == "6711" || $1 == "6712" || $1 == "6713" || $1 == "DA610") {if ($1 == "6711") {self.DSPSUBTYPE = 6711} , if ($1 == "6712") {self.DSPSUBTYPE = 6712} , if ($1 == "6713") {self.DSPSUBTYPE = 6713} } else {if ($1 == "DM642" || $1 == "6412" || $1 == "6414" || $1 == "6415" || $1 == "6416" || $1 == "6410" || $1 == "6413") {self.DSPSUBTYPE = 6400} }}}}, self.CHIPTYPE = $1, self.L2Check(), $e = "ok", if (GBL.CHIPCHAIN != nil) {$e = GBL.CHIPCHAIN.chipcall()} , $e)
    }
    global DISPCALLCSLCFGINIT :: = (self.CHIPTYPE != "other" && self.CHIPTYPE != "custom") { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Call CSL_cfgInit Initialization routine"
        prop Visible :: 0
        prop Writable :: self.SUPPORTCSL
        prop NoGen :: 1
    }
    global DSPNAME :: "TMS320C62XX" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global DSPARITHMETIC :: = (if (GBL.DSPTYPE == 62 && (GBL.DSPSUBTYPE / 100) == 67) {"FLOAT"} else {"FIXED"}) { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "FIXED,FLOAT"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global DSPWORDSIZE :: = (if (GBL.DSPTYPE == 30 || GBL.DSPTYPE == 40 || GBL.DSPTYPE == 62) {32} else {16}) { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "DSP Word Size"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global DSPCHARSIZE :: = (if GBL.DSPTYPE == 62 {8} else {if GBL.DSPSUBTYPE == 5599 {8} else {GBL.DSPWORDSIZE}}) { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "DSP Byte Size"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global DATAPTRSIZE :: = (if (GBL.DSPTYPE == 62) {32} else {if (GBL.DSPTYPE == 54) {16} else {if (GBL.DSPTYPE == 55) {if (GBL.MEMORYMODEL == "SMALL") {16} else {23}} else {if (GBL.DSPTYPE == 28) {22} else {0}}}}) { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop iComment :: "Size of the Data Pointer"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global CODEPTRSIZE :: = (if (GBL.DSPTYPE == 62) {32} else {if (GBL.DSPTYPE == 54) {if (GBL.CALLMODEL == "near") {16} else {24}} else {if (GBL.DSPTYPE == 55) {24} else {if (GBL.DSPTYPE == 28) {22} else {0}}}}) { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop iComment :: "Size of Code Pointer"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global ENDIAN :: "little" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "little,big"
        prop Label :: "DSP Endian Mode"
        prop JSName :: "ENDIANMODE"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
        prop Set :: (self.ENDIAN = $1, "ok")
    }
    global BIGENDIAN :: = if self.ENDIAN == "little" {0} else {1} { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    global AUTOINIT :: "ROM" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "ROM,RAM"
        prop Label :: "C Autoinitialization Model"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    global USERINIT :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Call User Init Function"
        prop JSName :: "CALLUSERINITFXN"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
        prop Set :: (if ($1 == 0) {self.USERINITFXN = @_FXN_F_nop, self.USERINIT = $1} else {self.USERINIT = $1}, "ok")
    }
    global USERINITFXN :: @_FXN_F_nop { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "User Init Function"
        prop JSName :: "USERINITFXN"
        prop Visible :: 1
        prop Writable :: self.USERINIT
        prop NoGen :: 0
    }
    global OLDAUTOCALCULATE :: 1 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "previous value for autocalculate"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global ENABLEINST :: 1 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Enable Real Time Analysis"
        prop JSName :: "ENABLEINST"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
        prop Set :: (if ($1 != self.ENABLEINST) {if ($1) {RTA_toHost.Create("HST"), RTA_toHost.bufseg = HST.OBJMEMSEG, RTA_fromHost.Create("HST"), RTA_fromHost.bufseg = HST.OBJMEMSEG, RTA_dispatcher.Create("HST"), IDL_busyObj.Create("IDL"), IDL.USEIDLBUSYOBJ = 1, IDL_cpuLoad.Create("IDL"), IDL.AUTOCALCULATE = self.OLDAUTOCALCULATE} else {if (self.LINKWITHROM) {self.LINKWITHROM = 0} , RTA_toHost.Delete("HST"), RTA_toHost.bufseg = MEM_NULL, RTA_fromHost.Delete("HST"), RTA_fromHost.bufseg = MEM_NULL, RTA_dispatcher.Delete("HST"), IDL_busyObj.Delete("IDL"), IDL.USEIDLBUSYOBJ = 0, IDL_cpuLoad.Delete("IDL"), self.OLDAUTOCALCULATE = IDL.AUTOCALCULATE, IDL.AUTOCALCULATE = 0}, self.ENABLEINST = $1} , "ok")
    }
    global INSTRUMENTED :: 1 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Use Instrumented BIOS library"
        prop JSName :: "INSTRUMENTED"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
    }
    global CGENERATE :: 1 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Do C Generation"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    global ENABLEDLL :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Enable Dynamic Loading"
        prop JSName :: "ENABLEDLL"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    global SUPPORTCSL :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop NoGen :: 0
    }
    global ENABLEALLTRC :: 1 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Enable All TRC Trace Event Classes"
        prop JSName :: "ENABLEALLTRC"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
        prop Set :: (if ($1) {self.TRCMASKVALUE = 0xDBEF} else {self.TRCMASKVALUE = 0x4000}, self.ENABLEALLTRC = $1, "ok")
    }
    global TRCMASKVALUE :: 56303 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop NoGen :: 0
    }
    global CALLCSLCFGINIT :: = self.DISPCALLCSLCFGINIT { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop NoGen :: 0
    }
    global CDBPATH :: "" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "CDB search path in COFF file"
        prop JSName :: "CDBRELATIVEPATH"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    global LINKWITHROM :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Link with ROM"
        prop JSName :: "LINKWITHROM"
        prop Visible :: 0
        prop Writable :: if (self.DSPSUBTYPE == 6799 && self.ENABLEINST) {1} else {0}
        prop NoGen :: 1
        prop Set :: ($e = "ok", if ($1) {$e = self.error("This BIOS version does not support linking with ROM.")} , $e)
    }
    global CACHE :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    global C64PL2CONFIGURE :: 1 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "64P - Configure Memory Cache Settings"
        prop JSName :: "C64PLUSCONFIGURE"
        prop Visible :: 1
        prop Writable :: 1
        prop TabName :: "64PLUS"
        prop Set :: ($e = "ok", self.C64PL2CONFIGURE = $1, $e = self.C64PL1PCacheSizeCheck(), if ($e == "ok") {$e = self.C64PL1DCacheSizeCheck(), if ($e == "ok") {$e = self.C64PL2CacheSizeCheck()} } , $e)
        prop NoGen :: 1
    }
    global L2CONFIGURE :: = (self.C64PL2CONFIGURE) { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop NoGen :: 0
    }
    global C64PL1PCFG :: "32k" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "64P L1PCFG Mode"
        prop Enum :: "0k,4k,8k,16k,32k"
        prop JSName :: "C64PLUSL1PCFG"
        prop Visible :: 1
        prop Writable :: if (GBL.C64PL2CONFIGURE == 1) {1} else {0}
        prop NoGen :: 1
        prop TabName :: "64PLUS"
        prop Set :: ($i = self.C64PL1PCFG, self.C64PL1PCFG = $1, $e = self.C64PL1PCacheSizeCheck(), if ($e != "ok") {self.C64PL1PCFG = $i} , $e)
    }
    global C64PL1DCFG :: "32k" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "64P L1DCFG Mode"
        prop Enum :: "0k,4k,8k,16k,32k"
        prop JSName :: "C64PLUSL1DCFG"
        prop Visible :: 1
        prop Writable :: if (GBL.C64PL2CONFIGURE == 1) {1} else {0}
        prop NoGen :: 1
        prop TabName :: "64PLUS"
        prop Set :: ($i = self.C64PL1DCFG, self.C64PL1DCFG = $1, $e = self.C64PL1DCacheSizeCheck(), if ($e != "ok") {self.C64PL1DCFG = $i} , $e)
    }
    global C64PL2MODEOPTS :: "0k" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "64P L2CFG Mode"
        prop Enum :: "0k,32k,64k,128k,256k"
        prop JSName :: "C64PLUSL2CFG"
        prop Visible :: 1
        prop Writable :: if (GBL.C64PL2CONFIGURE == 1) {1} else {0}
        prop NoGen :: 1
        prop TabName :: "64PLUS"
        prop Set :: ($i = self.C64PL2MODEOPTS, self.C64PL2MODEOPTS = $1, $e = self.C64PL2CacheSizeCheck(), if ($e != "ok") {self.C64PL2MODEOPTS = $i} , $e)
    }
    global L1PMODE :: = (self.setL1PMODE()) { 
        prop Type :: "{A11FE980-C07A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "0,1,2,3,7"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 0
    }
    global L1DMODE :: = (self.setL1DMODE()) { 
        prop Type :: "{A11FE980-C07A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "0,1,2,3,7"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 0
    }
    global L2MODE :: = (self.setL2MODE()) { 
        prop Type :: "{A11FE980-C07A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "0,1,2,3,7"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 0
    }
    global L2MAR0_31 :: 0 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "MAR 0-31 - bitmask"
        prop JSName :: "C64PLUSMAR0to31"
        prop Format :: "0x%08x"
        prop Style :: 0x02
        prop Visible :: 1
        prop Writable :: if (GBL.C64PL2CONFIGURE == 1) {1} else {0}
        prop NoGen :: 0
        prop TabName :: "64PLUS"
    }
    global L2MAR32_63 :: 0 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "MAR 32-63 - bitmask"
        prop JSName :: "C64PLUSMAR32to63"
        prop Format :: "0x%08x"
        prop Style :: 0x02
        prop Visible :: 1
        prop Writable :: if (GBL.C64PL2CONFIGURE == 1) {1} else {0}
        prop NoGen :: 0
        prop TabName :: "64PLUS"
    }
    global L2MAR64_95 :: 0 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "MAR 64-95 - bitmask"
        prop JSName :: "C64PLUSMAR64to95"
        prop Format :: "0x%08x"
        prop Style :: 0x02
        prop Visible :: 1
        prop Writable :: if (GBL.C64PL2CONFIGURE == 1) {1} else {0}
        prop NoGen :: 0
        prop TabName :: "64PLUS"
    }
    global L2MAR96_127 :: 0 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "MAR 96-127 - bitmask"
        prop JSName :: "C64PLUSMAR96to127"
        prop Format :: "0x%08x"
        prop Style :: 0x02
        prop Visible :: 1
        prop Writable :: if (GBL.C64PL2CONFIGURE == 1) {1} else {0}
        prop NoGen :: 0
        prop TabName :: "64PLUS"
    }
    global L2MAR128_159 :: 65535 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "MAR 128-159 - bitmask"
        prop JSName :: "C64PLUSMAR128to159"
        prop Format :: "0x%08x"
        prop Style :: 0x02
        prop Visible :: 1
        prop Writable :: if (GBL.C64PL2CONFIGURE == 1) {1} else {0}
        prop NoGen :: 0
        prop TabName :: "64PLUS"
    }
    global L2MAR160_191 :: 0 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "MAR 160-191 - bitmask"
        prop JSName :: "C64PLUSMAR160to191"
        prop Format :: "0x%08x"
        prop Style :: 0x02
        prop Visible :: 1
        prop Writable :: if (GBL.C64PL2CONFIGURE == 1) {1} else {0}
        prop NoGen :: 0
        prop TabName :: "64PLUS"
    }
    global L2MAR192_223 :: -1 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "MAR 192-223 - bitmask"
        prop JSName :: "C64PLUSMAR192to223"
        prop Format :: "0x%08x"
        prop Style :: 0x02
        prop Visible :: 1
        prop Writable :: if (GBL.C64PL2CONFIGURE == 1) {1} else {0}
        prop NoGen :: 0
        prop TabName :: "64PLUS"
    }
    global L2MAR224_255 :: 0 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "MAR 224-255 - bitmask"
        prop JSName :: "C64PLUSMAR224to255"
        prop Format :: "0x%08x"
        prop Style :: 0x02
        prop Visible :: 1
        prop Writable :: if (GBL.C64PL2CONFIGURE == 1) {1} else {0}
        prop NoGen :: 0
        prop TabName :: "64PLUS"
    }
    global ENABLE_SK :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: ""
        prop JSName :: "ENABLE_SK"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 0
        prop TabName :: "64PLUS"
    }
    global USEIDMA0DISPATCHER :: = 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop JSName :: "USEIDMA0DISPATCHER"
        prop Writable :: 1
        prop Visible :: 0
        prop NoGen :: 1
    }
    global GEMTRUECOMPEN :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "GEM True Completion Bit"
        prop JSName :: "GEMTRUECOMPEN"
        prop Visible :: (GBL.CLKTYPE == 2430 || GBL.CLKTYPE == 3430)
        prop Writable :: (GBL.CLKTYPE == 2430 || GBL.CLKTYPE == 3430)
        prop NoGen :: 0
        prop TabName :: "64PLUS"
    }
    global BCACHEREADADDR0 :: 0 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "BCACHE Read Address 0"
        prop JSName :: "BCACHEREADADDR0"
        prop Format :: "0x%08x"
        prop Style :: 0x02
        prop Visible :: (GBL.CLKTYPE == 2430 || GBL.CLKTYPE == 3430)
        prop Writable :: if (GBL.GEMTRUECOMPEN) {1} else {0}
        prop NoGen :: 0
        prop TabName :: "64PLUS"
    }
    global BCACHEREADADDR1 :: 0 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "BCACHE Read Address 1"
        prop JSName :: "BCACHEREADADDR1"
        prop Format :: "0x%08x"
        prop Style :: 0x02
        prop Visible :: (GBL.CLKTYPE == 2430 || GBL.CLKTYPE == 3430)
        prop Writable :: if (GBL.GEMTRUECOMPEN) {1} else {0}
        prop NoGen :: 0
        prop TabName :: "64PLUS"
    }
    global BCACHEREADADDR2 :: 0 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "BCACHE Read Address 2"
        prop JSName :: "BCACHEREADADDR2"
        prop Format :: "0x%08x"
        prop Style :: 0x02
        prop Visible :: (GBL.CLKTYPE == 2430 || GBL.CLKTYPE == 3430)
        prop Writable :: if (GBL.GEMTRUECOMPEN) {1} else {0}
        prop NoGen :: 0
        prop TabName :: "64PLUS"
    }
}

type MEM {
    isa ObjectMgr
    prop Label :: "MEM - Memory Section Manager"
    prop name :: "MEM"
    prop DependsOn :: "SEM"
    prop IsContainedIn :: SYSTEM
    prop GlobalIcon :: 115
    prop InstanceIcon :: 116
    prop GlobalHelpTopic :: (108)
    prop InstanceHelpTopic :: (208)
    prop InstancePropertyPage :: ("{3D658E70-05E7-11d0-BD44-0020AFEE33C8}")
    prop GlobalPropertyPage :: ("{3D658E71-05E7-11d0-BD44-0020AFEE33C8}")
    prop heapLabelStr :: (self.iHeapId)
    prop GenLinkPrologue :: (if (GBL.DSPTYPE == 55) {"-stack 0x%1x\n-sysstack 0x%2x\n\nMEMORY {%4t\0, _cmd55stksz, _cmd55systksz"} else {"-stack 0x%1x\nMEMORY {%4t\0, _stackSize"})
    prop _stackSize :: MEM.STACKSIZE
    prop AllocType :: (if (self.REUSE == 0 && self.USERCMD == 0) {"19\0,	_argsString,	_argsSeg,	_midPlace, 		_sysdataString,	_sysdataSeg,	_thirdPlace, 		_trcinitString,	_trcinitSeg,	_midPlace, 		_gblinitString,	_gblinitSeg,	_midPlace, 		_memObjString,	_memObjSeg,	_midPlace, 		_sysinitString,	_initSeg,	_sysinitPlace, 		_sysregsString,	_regsSeg,	_midPlace, 		_bssString,	_bssSeg,	_firstPlace, 		_farString,	_farSeg,	_secondPlace, 		_cinitString,	_cinitSeg,	_midPlace, 		_pinitString,	_pinitSeg,	_midPlace, 		_dataString,	_dataSeg,	_midPlace, 		_constString,	_constSeg,	_midPlace, 		_switchString,	_switchSeg,	_midPlace, 		_cioString,	_cioSeg,	_midPlace, 		_textString,	_textSeg,	_midPlace, 		_frtString,	_frtSeg,	_midPlace, 		_biosString,	_biosSeg,	_midPlace, 		_stackString,	_stackSeg,	_midPlace"} else {if (self.REUSE == 0 && self.USERCMD == 1) {"9\0,	_argsString,	_argsSeg,	_midPlace, 		_sysdataString,	_sysdataSeg,	_thirdPlace, 		_trcinitString,	_trcinitSeg,	_midPlace, 		_gblinitString,	_gblinitSeg,	_midPlace, 		_memObjString,	_memObjSeg,	_midPlace, 		_sysinitString,	_initSeg,	_sysinitPlace, 		_sysregsString,	_regsSeg,	_midPlace, 		_biosString,	_biosSeg,	_midPlace, 		_stackString,	_stackSeg,	_midPlace"} else {if (self.REUSE == 1 && self.USERCMD == 0) {"18\0,	_argsString,	_argsSeg,	_midPlace, 		_sysdataString,	_sysdataSeg,	_thirdPlace, 		_trcinitString,	_trcinitSeg,	_midPlace, 		_gblinitString,	_gblinitSeg,	_midPlace, 		_memObjString,	_memObjSeg,	_midPlace, 		_sysregsString,	_regsSeg,	_midPlace, 		_bssString,	_bssSeg,	_firstPlace, 		_farString,	_farSeg,	_secondPlace, 		_cinitString,	_cinitSeg,	_midPlace, 		_pinitString,	_pinitSeg,	_midPlace, 		_dataString,	_dataSeg,	_midPlace, 		_constString,	_constSeg,	_midPlace, 		_switchString,	_switchSeg,	_midPlace, 		_cioString,	_cioSeg,	_midPlace, 		_textString,	_textSeg,	_midPlace, 		_frtString,	_frtSeg,	_midPlace, 		_biosString,	_biosSeg,	_midPlace, 		_stackString,	_stackSeg,	_midPlace"} else {"8\0,	_argsString,	_argsSeg,	_midPlace, 		_sysdataString,	_sysdataSeg,	_thirdPlace, 		_trcinitString,	_trcinitSeg,	_midPlace, 		_gblinitString,	_gblinitSeg,	_midPlace, 		_memObjString,	_memObjSeg,	_midPlace, 		_sysregsString,	_regsSeg,	_midPlace, 		_biosString,	_biosSeg,	_midPlace, 		_stackString,	_stackSeg,	_midPlace"}}})
    prop _firstPlace :: 0
    prop _secondPlace :: 0 + 1
    prop _thirdPlace :: 0 + 2
    prop _midPlace :: (0x7fffffff / 2)
    prop _sysinitPlace :: (0x7fffffff / 2)
    prop _argsString :: ("%8t .args: align=4 fill=0 {%12t\n *(.args)\n . += 0x%1x;%8t\n }\0, _argsSize")
    prop _bssString :: ("%8t .bss:     {}")
    prop _farString :: ("%8t .far:     {}")
    prop _cinitString :: (if (self.ENABLELOADSEG == 1) {if (MEM.CINITSEG == MEM.LOADCINITSEG) {"%8t .cinit:    {}"} else {"%8t .cinit:   {} load > %1s, run\0, _loadcinitSeg"}} else {"%8t .cinit:    {}"})
    prop _pinitString :: (if (self.ENABLELOADSEG == 1) {if (MEM.PINITSEG == MEM.LOADPINITSEG) {"%8t .pinit:   {}"} else {"%8t .pinit:   {} load > %1s, run\0, _loadpinitSeg"}} else {"%8t .pinit:   {}"})
    prop _trcinitString :: (if (self.ENABLELOADSEG == 1) {if (MEM.TRCINITSEG == MEM.LOADTRCINITSEG) {"%8t .trcdata:   {}"} else {"%8t .trcdata:   {} load > %1s, run\0, _loadtrcinitSeg"}} else {"%8t .trcdata:    {}"})
    prop _gblinitString :: (if (self.ENABLELOADSEG == 1) {if (MEM.BIOSINITSEG == MEM.LOADBIOSINITSEG) {"%8t .gblinit:   {}"} else {"%8t .gblinit:   {} load > %1s, run\0, _loadgblinitSeg"}} else {"%8t .gblinit:    {}"})
    prop _dataString :: ("%8t .data:    {}")
    prop _constString :: (if (self.ENABLELOADSEG == 1) {if (MEM.CONSTSEG == MEM.LOADCONSTSEG) {"%8t GROUP {\n %8t .const: align = 0x8 {} \n %8t .printf (COPY): {} \n%8t }"} else {"%8t .const: align = 0x8 {} load > %1s run\0, _loadconstSeg"}} else {"%8t GROUP {\n %8t .const: align = 0x8 {} \n %8t .printf (COPY): {} \n%8t }"})
    prop _switchString :: (if (self.ENABLELOADSEG == 1) {if (MEM.SWITCHSEG == MEM.LOADSWITCHSEG) {"%8t .switch:   {}"} else {"%8t .switch:   {} load > %1s, run\0, _loadswitchSeg"}} else {"%8t .switch:    {}"})
    prop _sysmemString :: ("%8t .sysmem:  {}")
    prop _cioString :: ("%8t .cio:     {}")
    prop _memObjString :: ("%8t .mem: 	  {}")
    prop _sysdataString :: (if ((GBL.ROM == 0) && (GBL.DSPTYPE == 54)) {"%8t .sysdata: align = 128 {%12t\n GBL_A_SYSPAGE = .;\n GBL_A_SYSDP = GBL_A_SYSPAGE >> 7;\n %8t }"} else {"%8t .sysdata: {}"})
    prop _sysinitString :: (if (self.ENABLELOADSEG == 1) {if (MEM.INITSEG == MEM.LOADINITSEG) {"%8t .sysinit:   {}"} else {"%8t .sysinit:   {} load > %1s, run\0, _loadinitSeg"}} else {"%8t .sysinit:    {}"})
    prop _sysregsString :: ("%8t .sysregs: {}")
    prop _textString :: (if (self.ENABLELOADSEG == 1) {if (MEM.TEXTSEG == MEM.LOADTEXTSEG) {"%8t .text:    {}"} else {"%8t .text:    {} load > %1s, run\0, _loadtextSeg"}} else {"%8t .text:    {}"})
    prop _frtString :: ("%8t frt:    {}")
    prop _biosString :: (if (self.ENABLELOADSEG == 1) {if (MEM.BIOSSEG == MEM.LOADBIOSSEG) {"%8t .bios:    {}"} else {"%8t .bios:    {} load > %1s, run\0, _loadbiosSeg"}} else {"%8t .bios:    {}"})
    prop _stackString :: (if (GBL.DSPTYPE == 62) {"%8t .stack: align = 0x8 {%12t\n GBL_stackbeg = .;\n *(.stack)\n GBL_stackend = GBL_stackbeg + 0x%1x - 1;%12t\n _HWI_STKBOTTOM = GBL_stackbeg + 0x%1x - 8;%12t\n _HWI_STKTOP = GBL_stackbeg;%8t\n }\0, _stackSize, _stackSize"} else {if (GBL.DSPTYPE == 54) {"%8t .stack: {%12t\n GBL_stackbeg = .;\n *(.stack)\n GBL_stackend = ((GBL_stackbeg + 0x%1x - 1) & 0xfffe) ;%8t\n _HWI_STKBOTTOM = GBL_stackend;%12t\n _HWI_STKTOP = GBL_stackbeg;%8t\n }\0, _stackSize"} else {if (GBL.DSPTYPE == 55) {"%8t GROUP { \n%16t .sysstack :  align = 0x4 {%12t\n %16t GBL_sysstackbeg = .;\n %16t *(.sysstack)\n %16t GBL_sysstackend = GBL_sysstackbeg + 0x%2x -1 ;%12t\n %16t _HWI_SYSSTKTOP = GBL_sysstackbeg; %12t\n %16t_HWI_SYSSTKBOTTOM = (GBL_sysstackend+1);\n%16t} \n%16t .stack: align = 0x4 {%12t\n %16t GBL_stackbeg = .;\n %16t *(.stack)\n GBL_stackend = (GBL_stackbeg + 0x%1x - 1) ;%12t\n %16t _HWI_STKBOTTOM = (GBL_stackend+1);%12t\n %16t _HWI_STKTOP = (GBL_stackbeg);%16t\n }%8t\n } BLOCK(0x20000), run \0, _cmd55stksz, _cmd55systksz"} else {"%8t .stack: {%12t\n GBL_stackbeg = .;\n *(.stack)\n GBL_stackend = GBL_stackbeg + 0x%1x - 1;%8t\n _HWI_STKBOTTOM = GBL_stackbeg;%12t\n _HWI_STKTOP = (GBL_stackend + 1);%8t\n }\0, _stackSize"}}})
    prop _memHdrSize :: 8
    prop GenLinkEpilogue :: ("%0t}")
    prop _stackSeg :: MEM.STACKSEG
    prop _textSeg :: MEM.TEXTSEG
    prop _frtSeg :: MEM.TEXTSEG
    prop _biosSeg :: MEM.BIOSSEG
    prop _dataSeg :: MEM.DATASEG
    prop _cioSeg :: MEM.CIOSEG
    prop _sysmemSeg :: MEM.SYSMEMSEG
    prop _constSeg :: MEM.CONSTSEG
    prop _initSeg :: MEM.INITSEG
    prop _pinitSeg :: MEM.PINITSEG
    prop _trcinitSeg :: MEM.TRCINITSEG
    prop _gblinitSeg :: MEM.BIOSINITSEG
    prop _regsSeg :: MEM.SYSDATASEG
    prop _sysdataSeg :: MEM.SYSDATASEG
    prop _argsSeg :: MEM.ARGSSEG
    prop _argsSize :: MEM.ARGSSIZE
    prop _bssSeg :: MEM.BSSSEG
    prop _farSeg :: MEM.FARSEG
    prop _cinitSeg :: MEM.CINITSEG
    prop _memObjSeg :: MEM.CFGOBJSEG
    prop _switchSeg :: MEM.SWITCHSEG
    prop _loadtextSeg :: MEM.LOADTEXTSEG
    prop _loadbiosSeg :: MEM.LOADBIOSSEG
    prop _loadconstSeg :: MEM.LOADCONSTSEG
    prop _loadinitSeg :: MEM.LOADINITSEG
    prop _loadpinitSeg :: MEM.LOADPINITSEG
    prop _loadtrcinitSeg :: MEM.LOADTRCINITSEG
    prop _loadgblinitSeg :: MEM.LOADBIOSINITSEG
    prop _loadcinitSeg :: MEM.LOADCINITSEG
    prop _loadswitchSeg :: MEM.LOADSWITCHSEG
    prop AllocInst :: (if (self.iAllocHeap == 1) {"1\0, _instAllocDesc, _objMemSeg, _placement"} )
    prop _instAllocDesc :: (if self.INITSEG.iAllocHeap && self.REUSE && self.INITSEG == self {"%8t GROUP {%12t\n .sysinitgap {. += 0x%2x;}\n .sysinit:\n .%0r$heap: {%16t\n . += 0x%1x;%12t\n }%8t\n } RUN_START(%0r$B), RUN_START(_%0r_base), RUN_SIZE(%0r$L), RUN_SIZE(_%0r_length)\0, _heapsize, _sysinitgap, _heaplen"} else {"%8t .%0r$heap: {%12t\n . += 0x%1x;%8t\n } RUN_START(%0r$B), RUN_START(_%0r_base), RUN_SIZE(%0r$L), RUN_SIZE(_%0r_length)\0, _heapsize, _heaplen"})
    prop _objMemSeg :: self
    prop _placement :: 0x7fffffff - 1
    prop _heapsize :: (self.iHeapSize)
    prop _heaplen :: (self.iHeapSize)
    prop _sysinitgap :: 2 * 4
    prop GenInstLink :: (if GBL.DSPTYPE == 62 {"%0r %16t: origin = 0x%1x, %40tlen = 0x%2x%4t\0, _origin, _len"} else {if GBL.DSPTYPE == 55 {"PAGE %3d: %16t%0r: %26torigin = 0x%1x, %40tlen = 0x%2x%4t\0, _cmd55origin, _cmd55len, _page"} else {"PAGE %3d: %14t%0r: %26torigin = 0x%1x, %50tlen = 0x%2x%4t\0, _origin, _len, _page"}})
    prop localInit :: ($d = "ok", scan ($i; MEM) {if ($i.space == "code" && $i.iAllocHeap == 1) {$d = self.error("Code memory cannot have a heap")} }, if (self.SEGZERO.iAllocHeap == 1) {self.SEGZERO.iReqHeapCount++} else {$d = self.error("Segment for DSP/BIOS objects must be a memory segment with a heap")}, if (self.MALLOCSEG.iAllocHeap == 1) {self.MALLOCSEG.iReqHeapCount++} else {$d = self.error("Segment for malloc()/free() must be a memory segment with a heap")}, $d)
    prop _page :: (self.page)
    prop _origin :: (self.base)
    prop _len :: (self.len)
    prop maxObjs :: (32767)
    prop codeMember :: (if $1.dynamicLoading == 1 {0} else {if GBL.DSPTYPE == 62 {(($1.space == "code") || ($1.space == "code/data"))} else {if GBL.DSPTYPE == 54 {($1.space == "code")} else {if GBL.DSPTYPE == 28 {($1.space == "code" || ($1.space == "code/data"))} else {if GBL.DSPTYPE == 55 {(($1.space == "code") || ($1.space == "code/data"))} else {($1.space == "code/data")}}}}})
    prop dataMember :: (if $1.dynamicLoading == 1 {0} else {if GBL.DSPTYPE == 62 {($1.space == "data" || $1.space == "code/data") && $1 != MEM_NULL} else {if GBL.DSPTYPE == 54 {(($1.space != "code") && ($1 != MEM_NULL)) && $1.space != "io"} else {if GBL.DSPTYPE == 28 {($1.space == "data" || $1.space == "code/data") && $1 != MEM_NULL} else {if GBL.DSPTYPE == 55 {($1.space == "data" || $1.space == "code/data") && $1 != MEM_NULL} else {(($1.space == "code/data") && ($1 != MEM_NULL))}}}}})
    prop dataNullMember :: (if $1.dynamicLoading == 1 {0} else {if GBL.DSPTYPE == 62 {$1.space == "data" || $1.space == "code/data"} else {if GBL.DSPTYPE == 54 {$1.space != "code" && $1.space != "io"} else {if GBL.DSPTYPE == 28 {$1.space == "data" || $1.space == "code/data"} else {if GBL.DSPTYPE == 55 {$1.space == "data" || $1.space == "code/data"} else {$1.space == "code/data"}}}}})
    prop dataCodeMember :: (if $1.dynamicLoading == 1 {0} else {if GBL.DSPTYPE == 62 {($1.space == "data" || $1.space == "code/data") && $1 != MEM_NULL} else {if GBL.DSPTYPE == 54 {$1.space == "code" && $1 != MEM_NULL} else {if GBL.DSPTYPE == 28 {($1.space == "code" || $1.space == "code/data") && $1 != MEM_NULL} else {if GBL.DSPTYPE == 55 {($1.space == "data" || $1.space == "code/data") && $1 != MEM_NULL} else {$1.space == "code/data" && $1 != MEM_NULL}}}}})
    prop memWritable :: (self.iIsModifiable && self.iDelUser != "MEM")
    prop validate :: ($e = self.checkMemOverlap($1), if ($e == "ok") {$e = self.checkHeapSize($1)} , if ($e == "ok") {$e = self.checkHeapSeg($1)} , $e)
    prop checkHeapSeg :: ($e = "ok", if ($1 == MEM_NULL && MEM.NOHEAPS == 0) {if (MEM.MALLOCSEG == MEM_NULL) {$e = ("Heaps are enabled, but the segment for malloc (MEM.MALLOCSEG) is not set correctly. Please create a heap in one of your data segments and set MEM.MALLOCSEG to it.")} , if (MEM.SEGZERO == MEM_NULL) {$e = ("Heaps are enabled, but the segment for DSP/BIOS Objects (MEM.BIOSOBJSEG) is not set correctly. Please create a heap in one of your data segments and set MEM.BIOSOBJSEG to it.")} } , $e)
    prop checkHeapSize :: ($e = "ok", if (MEM.NOHEAPS == 0) {if ($1.iAllocHeap && $1 != MEM_NULL) {if ($1.iHeapSize > $1.len) {$e = ("MEM segment %s: heap cannot be larger than the length of segment that contains it.")} } } , $e)
    prop checkMemOverlap :: ($e = "ok", if ($1 != MEM_NULL && $1.iIsUsed == 1) {if ($1.len == 0) {$a = $1.base} else {$a = ($1.base + $1.len - 1)}, scan ($j; MEM) {if ($1 != $j && $j != MEM_NULL && $j.iIsUsed == 1 && (GBL.DSPTYPE == 62 || $1.space == $j.space)) {if (!($j == CACHE_L2 && GBL.L2CONFIGURE == 0)) {$b = $j.base, if ($j.len == 0) {$c = $j.base} else {$c = ($j.base + $j.len - 1)}, if ($a >= $b && $1.base <= $c) {$e = ("MEM segment %s: overlaps with another segment or cache configuration."), break} } } }} , $e)
    prop _spaceEnum :: (self.ENUMSPACE)
    prop checkHeapId :: ($e = "ok", scan ($i; MEM) {if ($i.iAllocHeap == 1 && $i.iUserHeapId == 1 && $i.iHeapId == $1 && $i.iHeapId != @segment_name) {$e = self.error("This identifier label is already in use"), break} }, $e)
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 5 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global CALLBACKOBJ :: nil { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumHeap :: = ($a = 0, scan ($i; MEM) {if ($i != MEM_NULL) {$a += $i.iAllocHeap} }, $a) { 
        prop NoGen :: 0
    }
    global REUSE :: = (if self.INITSEG.space != "code" && self.INITSEG.iAllocHeap == 1 {self.SAVEREUSE} else {0}) { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Reuse Startup Code Space"
        prop JSName :: "REUSECODESPACE"
        prop Visible :: 1
        prop Writable :: self.INITSEG.space != "code" && self.INITSEG.iAllocHeap == 1
        prop NoGen :: 1
        prop Set :: (self.SAVEREUSE = $1, "ok")
    }
    global SAVEREUSE :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop NoGen :: 1
    }
    global doCheckOverlap :: 1 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    global MAPSELECT :: "Map 1" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Map Mode"
        prop JSName :: "MAPMODE"
        prop Enum :: "Map 0,Map 1"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global ARGSSIZE :: 4 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04x"
        prop Style :: 0x01 | 0x02
        prop Label :: "Argument Buffer Size"
        prop JSName :: "ARGSSIZE"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
        prop Set :: (if ($1 < 4) {self.error("The 'arguments' section must have at least 4 words.")} else {self.ARGSSIZE = $1, "ok"})
    }
    global ARGSSEG :: IRAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: self.dataMember($1)
        prop Label :: "Argument Buffer Section (.args)"
        prop JSName :: "ARGSSEG"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
        prop TabName :: "BIOS Data"
    }
    global BIOSSEG :: DDR { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: self.codeMember($1)
        prop Label :: "BIOS Code Section (.bios)"
        prop JSName :: "BIOSSEG"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
        prop TabName :: "BIOS Code"
    }
    global STACKSIZE :: 65536 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04x"
        prop Style :: if GBL.DSPTYPE == 54 {0x01 | 0x02} else {0x02}
        prop Label :: "Stack Size (MAUs)"
        prop JSName :: "STACKSIZE"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
        prop Set :: (if ((GBL.DSPTYPE == 55) && (GBL.DSPSUBTYPE != 5599)) {self.STACKSIZE = ($1 & -2)} else {if ((GBL.DSPTYPE == 55) && (GBL.DSPSUBTYPE == 5599)) {self.STACKSIZE = ($1 & -4)} else {self.STACKSIZE = $1}}, "ok")
        prop PropSetOkUserMsg :: if (MEM.STACKSIZE < GlobalStatus.MinStackSize) {"Warning: You are setting the stack size to a value that is less than the Estimated Minimum Stack Size!"} else {"ok"}
    }
    global USERCMD :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "User .cmd File For Compiler Sections"
        prop JSName :: "USERCOMMANDFILE"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
        prop TabName :: "Compiler Sections"
    }
    global STACKSEG :: IRAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: self.dataMember($1)
        prop Label :: "Stack Section (.stack)"
        prop JSName :: "STACKSEG"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
        prop TabName :: "BIOS Data"
        prop Set :: (if (GBL.DSPTYPE == 55) {(MEM.STACKSEG = $1), (MEM.SYSSTACKSEG = $1)} else {(MEM.STACKSEG = $1)}, "ok")
    }
    global ENABLELOADSEG :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Specify Separate Load Addresses"
        prop JSName :: "ENABLELOADADDR"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
        prop TabName :: "Load Address"
    }
    global LOADBIOSSEG :: DDR { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: self.codeMember($1)
        prop Label :: "Load Address - BIOS Code Section (.bios)"
        prop JSName :: "LOADBIOSSEG"
        prop Visible :: 1
        prop Writable :: (self.ENABLELOADSEG == 1)
        prop NoGen :: 1
        prop TabName :: "Load Address"
    }
    global INITSEG :: DDR { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: self.codeMember($1)
        prop Label :: "Startup Code Section (.sysinit)"
        prop JSName :: "SYSINITSEG"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
        prop TabName :: "BIOS Code"
    }
    global LOADINITSEG :: DDR { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: self.codeMember($1)
        prop Label :: "Load Address - Startup Code Section (.sysinit)"
        prop JSName :: "LOADSYSINITSEG"
        prop Visible :: 1
        prop Writable :: (self.ENABLELOADSEG == 1)
        prop NoGen :: 1
        prop TabName :: "Load Address"
    }
    global BIOSINITSEG :: IRAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: self.dataCodeMember($1)
        prop Label :: "DSP/BIOS Init Tables (.gblinit)"
        prop JSName :: "GBLINITSEG"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
        prop TabName :: "BIOS Data"
    }
    global TRCINITSEG :: IRAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: self.dataCodeMember($1)
        prop Label :: "TRC Initial Value (.trcdata)"
        prop JSName :: "TRCDATASEG"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
        prop TabName :: "BIOS Data"
    }
    global LOADBIOSINITSEG :: IRAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: self.dataCodeMember($1)
        prop Label :: "Load Address - DSP/BIOS Init Tables (.gblinit)"
        prop JSName :: "LOADGBLINITSEG"
        prop Visible :: 1
        prop Writable :: (self.ENABLELOADSEG == 1)
        prop NoGen :: 1
        prop TabName :: "Load Address"
    }
    global LOADTRCINITSEG :: IRAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: self.dataCodeMember($1)
        prop Label :: "Load Address - TRC Initial Value (.trcdata)"
        prop JSName :: "LOADTRCDATASEG"
        prop Visible :: 1
        prop Writable :: (self.ENABLELOADSEG == 1)
        prop NoGen :: 1
        prop TabName :: "Load Address"
    }
    global SYSDATASEG :: IRAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: self.dataMember($1)
        prop Label :: "DSP/BIOS Kernel State (.sysdata)"
        prop JSName :: "SYSDATASEG"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
        prop TabName :: "BIOS Data"
    }
    global CFGOBJSEG :: IRAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: self.dataMember($1)
        prop Label :: "DSP/BIOS Conf Sections (.*obj)"
        prop JSName :: "OBJSEG"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
        prop TabName :: "BIOS Data"
    }
    global NOHEAPS :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "No Dynamic Memory Heaps"
        prop JSName :: "NOMEMORYHEAPS"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
        prop Set :: (if ($1) {self.SEGZERO.iReqHeapCount--, self.SEGZERO = MEM_NULL, self.MALLOCSEG.iReqHeapCount--, self.MALLOCSEG = MEM_NULL, TSK.STACKSEG.iReqHeapCount--, TSK.STACKSEG = MEM_NULL, scan ($i; MEM) {if ($i.iAllocHeap && $i != MEM_NULL) {$i.iAllocHeap = 0, $i.iHeapSize = 0} }} , self.NOHEAPS = $1, "ok")
        prop PropSetOkUserMsg :: if (MEM.NOHEAPS == 1) {"Currently specified heaps no longer valid"} else {"Please reconfigure heaps under individual mem segments"}
    }
    global SEGZERO :: DDR { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: (self.dataNullMember($1) && $1.iAllocHeap)
        prop Label :: "Segment For DSP/BIOS Objects"
        prop JSName :: "BIOSOBJSEG"
        prop Visible :: 1
        prop Writable :: MEM.NOHEAPS == 0
        prop NoGen :: 0
        prop Set :: (if (self.SEGZERO.iReqHeapCount > 0) {self.SEGZERO.iReqHeapCount--} , self.SEGZERO = $1, self.SEGZERO.iReqHeapCount++, "ok")
    }
    global MALLOCSEG :: DDR { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: (self.dataNullMember($1) && $1.iAllocHeap)
        prop Label :: "Segment For malloc() / free()"
        prop JSName :: "MALLOCSEG"
        prop Visible :: 1
        prop Writable :: (MEM.NOHEAPS == 0)
        prop NoGen :: 0
        prop Set :: (if (self.MALLOCSEG.iReqHeapCount > 0) {self.MALLOCSEG.iReqHeapCount--} , self.MALLOCSEG = $1, self.MALLOCSEG.iReqHeapCount++, "ok")
    }
    global USEMPC :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Enable Memory Protection Controller module"
        prop JSName :: "USEMPC"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
    }
    global LNKCMDFILE :: "" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Specify User Linker cmd File"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    global TEXTSEG :: DDR { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: (self.codeMember($1))
        prop Label :: "Text Section (.text)"
        prop JSName :: "TEXTSEG"
        prop Visible :: 1
        prop Writable :: (self.USERCMD == 0)
        prop NoGen :: 1
        prop TabName :: "Compiler Sections"
    }
    global LOADTEXTSEG :: DDR { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: (self.codeMember($1))
        prop Label :: "Load Address - Text Section (.text)"
        prop JSName :: "LOADTEXTSEG"
        prop Visible :: 1
        prop Writable :: (self.USERCMD == 0 && self.ENABLELOADSEG == 1)
        prop NoGen :: 1
        prop TabName :: "Load Address"
    }
    global SWITCHSEG :: IRAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: (self.dataCodeMember($1))
        prop Label :: "Switch Jump Tables (.switch)"
        prop JSName :: "SWITCHSEG"
        prop Visible :: 1
        prop Writable :: (self.USERCMD == 0)
        prop NoGen :: 1
        prop TabName :: "Compiler Sections"
    }
    global LOADSWITCHSEG :: IRAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: (self.dataCodeMember($1))
        prop Label :: "Load Address - Switch Jump Tables (.switch)"
        prop JSName :: "LOADSWITCHSEG"
        prop Visible :: 1
        prop Writable :: (self.USERCMD == 0 && self.ENABLELOADSEG == 1)
        prop NoGen :: 1
        prop TabName :: "Load Address"
    }
    global BSSSEG :: IRAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: (self.dataMember($1))
        prop Label :: "C Variables Section (.bss)"
        prop JSName :: "BSSSEG"
        prop Visible :: 1
        prop Writable :: (self.USERCMD == 0)
        prop NoGen :: 1
        prop TabName :: "Compiler Sections"
    }
    global FARSEG :: IRAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: (self.dataMember($1))
        prop Label :: "C Variables Section (.far)"
        prop JSName :: "FARSEG"
        prop Visible :: if GBL.DSPTYPE == 62 {1} else {0}
        prop Writable :: (self.USERCMD == 0)
        prop NoGen :: 1
        prop TabName :: "Compiler Sections"
    }
    global CINITSEG :: IRAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: (self.dataCodeMember($1))
        prop Label :: "Data Initialization Section (.cinit)"
        prop JSName :: "CINITSEG"
        prop Visible :: 1
        prop Writable :: (self.USERCMD == 0)
        prop NoGen :: 1
        prop TabName :: "Compiler Sections"
    }
    global LOADCINITSEG :: IRAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: (self.dataCodeMember($1))
        prop Label :: "Load Address - Data Initialization Section (.cinit)"
        prop JSName :: "LOADCINITSEG"
        prop Visible :: 1
        prop Writable :: (self.USERCMD == 0 && self.ENABLELOADSEG == 1)
        prop NoGen :: 1
        prop TabName :: "Load Address"
    }
    global PINITSEG :: IRAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: (self.dataCodeMember($1))
        prop Label :: "C Function Initialization Table (.pinit)"
        prop JSName :: "PINITSEG"
        prop Visible :: 1
        prop Writable :: (self.USERCMD == 0)
        prop NoGen :: 1
        prop TabName :: "Compiler Sections"
    }
    global LOADPINITSEG :: IRAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: (self.dataCodeMember($1))
        prop Label :: "Load Address - C Function Initialization Table (.pinit)"
        prop JSName :: "LOADPINITSEG"
        prop Visible :: 1
        prop Writable :: (self.USERCMD == 0 && self.ENABLELOADSEG == 1)
        prop NoGen :: 1
        prop TabName :: "Load Address"
    }
    global CONSTSEG :: IRAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: (self.dataMember($1))
        prop Label :: "Constant Sections (.const, .printf)"
        prop JSName :: "CONSTSEG"
        prop Visible :: 1
        prop Writable :: (self.USERCMD == 0)
        prop NoGen :: 1
        prop TabName :: "Compiler Sections"
    }
    global LOADCONSTSEG :: IRAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: (self.dataMember($1))
        prop Label :: "Load Address - Constant Sections (.const, .printf)"
        prop JSName :: "LOADCONSTSEG"
        prop Visible :: 1
        prop Writable :: (self.USERCMD == 0 && self.ENABLELOADSEG == 1)
        prop NoGen :: 1
        prop TabName :: "Load Address"
    }
    global DATASEG :: IRAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: (self.dataMember($1))
        prop Label :: "Data Section (.data)"
        prop JSName :: "DATASEG"
        prop Visible :: 1
        prop Writable :: (self.USERCMD == 0)
        prop NoGen :: 1
        prop TabName :: "Compiler Sections"
    }
    global CIOSEG :: IRAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: (self.dataMember($1))
        prop Label :: "Data Section (.cio)"
        prop JSName :: "CIOSEG"
        prop Visible :: 1
        prop Writable :: (self.USERCMD == 0)
        prop NoGen :: 1
        prop TabName :: "Compiler Sections"
        prop Set :: (self.CIOSEG = $1, self.SYSMEMSEG = $1, "ok")
    }
    global SYSMEMSEG :: IRAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: (self.dataMember($1))
        prop Label :: "Data Section (.sysmem)"
        prop JSName :: "SYSMEMSEG"
        prop Visible :: 0
        prop Writable :: (self.USERCMD == 0)
        prop NoGen :: 1
        prop TabName :: "Compiler Sections"
    }
    global STUBMEMSEG :: DDR { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: MEM.codeMember($1)
        prop Label :: "Function Stub Memory (.hwi)"
        prop JSName :: "HWISEG"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
        prop TabName :: "BIOS Code"
        prop Set :: (self.STUBMEMSEG = $1, HWI.STUBMEMSEG = $1, "ok")
    }
    global LOADSTUBMEMSEG :: DDR { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: MEM.codeMember($1)
        prop Label :: "Load Address - Function Stub Memory (.hwi)"
        prop JSName :: "LOADHWISEG"
        prop Visible :: 1
        prop Writable :: (self.ENABLELOADSEG == 1)
        prop NoGen :: 1
        prop TabName :: "Load Address"
    }
    global VECMEMSEG :: DDR { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: MEM.codeMember($1)
        prop Label :: "Interrupt Service Table Memory (.hwi_vec)"
        prop JSName :: "HWIVECSEG"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
        prop TabName :: "BIOS Code"
        prop Set :: (self.VECMEMSEG = $1, HWI.VECMEMSEG = $1, GlobalStatus.gDirty = 1, if ($1.base == 0) {HWI.GENERATE_RESET_VEC = 0} , "ok")
    }
    global LOADVECMEMSEG :: DDR { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: MEM.codeMember($1)
        prop Label :: "Load Address -Interrupt Service Table Memory (.hwi_vec)"
        prop JSName :: "LOADHWIVECSEG"
        prop Visible :: 1
        prop Writable :: (self.ENABLELOADSEG == 1)
        prop NoGen :: 1
        prop TabName :: "Load Address"
    }
    global RTDXTEXTMEMSEG :: DDR { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: MEM.codeMember($1)
        prop Label :: "RTDX Text Segment (.rtdx_text)"
        prop JSName :: "RTDXTEXTSEG"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
        prop TabName :: "BIOS Code"
        prop Set :: (self.RTDXTEXTMEMSEG = $1, RTDX.TEXTMEMSEG = $1, "ok")
    }
    global LOADRTDXTEXTMEMSEG :: DDR { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: MEM.codeMember($1)
        prop Label :: "Load Address - RTDX Text Segment (.rtdx_text)"
        prop JSName :: "LOADRTDXTEXTSEG"
        prop Visible :: 1
        prop Writable :: (self.ENABLELOADSEG == 1)
        prop NoGen :: 1
        prop TabName :: "Load Address"
    }
    global ENUMSPACE :: = if GBL.DSPTYPE == 62 {"code,data,code/data,reserved"} else {if GBL.DSPTYPE == 54 {"code,data,io,other,reserved"} else {if GBL.DSPTYPE == 28 {"code,code/data,data,io,other,reserved"} else {if GBL.DSPTYPE == 55 {"code/data,code,data,io,reserved"} else {"code/data,io,reserved"}}}} { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop JSName :: "ENUMSPACE"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iComment :: if self.iDelUser == "USER" {"<add comments here>"} else {self.iDelMsg} { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "comment"
        prop JSName :: "comment"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "USER" {1} else {0}
        prop NoGen :: 1
    }
    inst iIsUsed :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iId :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iDelUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDelMsg :: "ok" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst base :: 0 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: if GBL.DSPTYPE == 62 {"0x%08x"} else {"0x%06x"}
        prop Style :: 0x02
        prop Label :: "base"
        prop JSName :: "base"
        prop Visible :: 1
        prop Writable :: (self.iIsModifiable)
        prop NoGen :: 1
        prop Set :: ($e = "ok", $a = self.base, self.base = $1, if (MEM.CALLBACKOBJ != nil) {$e = MEM.CALLBACKOBJ.call(self), if ($e != "ok") {self.base = $a} } , $e)
    }
    inst len :: 0 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: if GBL.DSPTYPE == 62 {"0x%08x"} else {"0x%04x"}
        prop Style :: 0x08
        prop Label :: "len"
        prop JSName :: "len"
        prop Visible :: 1
        prop Writable :: (self.memWritable)
        prop NoGen :: 0
        prop Set :: ($e = "ok", $a = self.len, self.len = $1, if (MEM.CALLBACKOBJ != nil) {$e = MEM.CALLBACKOBJ.call(self), if ($e != "ok") {self.len = $a} } , "ok")
    }
    inst page :: = (if GBL.DSPTYPE == 62 {-1} else {if (GBL.DSPTYPE == 55 || GBL.DSPTYPE == 28) {(if self.space == "code" {0} else {if self.space == "data" {1} else {if self.space == "io" {2} else {0}}})} else {if self.space == "code" {0} else {if self.space == "data" {1} else {if self.space == "io" {2} else {3}}}}}) { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop NoGen :: 1
    }
    inst iAllocHeap :: if MEM.NOHEAPS == 1 {0} else {1} { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "create a heap in this memory"
        prop JSName :: "createHeap"
        prop Visible :: 1
        prop Writable :: (self.space == "data" || self.space == "code/data") && (MEM.NOHEAPS == 0) && self.memWritable
        prop NoGen :: 0
        prop Set :: ($a = "ok", if ($1 == 0 && self.iReqHeapCount > 0) {self.error("This heap is used by one or more of: segment for DSP/BIOS objects, segment for malloc()/free(), TSK default stack segment")} else {if ($1 == 0) {self.iUserHeapId = 0, self.iHeapId = @segment_name} , self.iAllocHeap = $1, MEM.gDirty = 1, $a})
    }
    inst iHeapSize :: 0x8000 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: if GBL.DSPTYPE == 62 {"0x%08x"} else {"0x%04x"}
        prop Style :: 0x02
        prop Label :: "heap size"
        prop JSName :: "heapSize"
        prop Visible :: 1
        prop Writable :: (self.iAllocHeap) && (self.iIsModifiable) && (MEM.NOHEAPS == 0)
        prop Set :: (self.iHeapSize = $1, "ok")
        prop NoGen :: 1
    }
    inst iSegZero :: = MEM.SEGZERO
    inst iUserHeapId :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "enter a user defined heap identifier label"
        prop JSName :: "enableHeapLabel"
        prop Set :: (if ($1 == 0) {self.iHeapId = @segment_name} , self.iUserHeapId = $1, "ok")
        prop Visible :: 1
        prop Writable :: (self.iAllocHeap) && (self.iIsModifiable) && (self.NOHEAPS == 0)
        prop NoGen :: 1
    }
    inst iHeapId :: @segment_name { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "heap identifier label"
        prop JSName :: "heapLabel"
        prop Set :: ($e = self.checkHeapId($1), if ($e == "ok") {self.iHeapId = $1} , $e)
        prop Writable :: (self.iAllocHeap) && (self.iIsModifiable) && (self.NOHEAPS == 0) && (self.iUserHeapId)
        prop Visible :: 1
        prop NoGen :: 0
    }
    inst iReqHeapCount :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop NoGen :: 1
    }
    inst space :: (if GBL.DSPTYPE == 55 {"code/data"} else {"data"}) { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: MEM._spaceEnum()
        prop JSName :: "space"
        prop Visible :: 1
        prop Writable :: (self.memWritable)
        prop NoGen :: 1
        prop Set :: ($e = "ok", if ($1 != "data" && $1 != "code/data" && self.iAllocHeap == 1) {$e = self.error("Cannot select this space if a heap will be created")} else {$a = self.space, self.space = $1, if (MEM.CALLBACKOBJ != nil) {$e = MEM.CALLBACKOBJ.call(self), if ($e != "ok") {self.space = $a} } }, $e)
    }
    inst dynamicLoading :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Reserved for dynamic loading"
        prop JSName :: "dynamicLoading"
        prop Visible :: GBL.ENABLEDLL
        prop Writable :: GBL.ENABLEDLL
        prop NoGen :: 1
    }
    inst iIsModifiable :: 1 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
}

object MEM_NULL :: MEM {
    param iComment :: "Place holder segment which allows user to disable heaps"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "USER"
    param iDelMsg :: "ok"
    param base :: 0
    param len :: 0
    param iAllocHeap :: 1
    param iHeapSize :: 32768
    param iUserHeapId :: 0
    param iHeapId :: @segment_name
    param iReqHeapCount :: 0
    param space :: "data"
    param dynamicLoading :: 0
    param iIsModifiable :: 1
}

type OBJ {
    isa ObjectMgr
    prop name :: "OBJ"
    prop Visible :: 0
    prop AllocType :: (if (self.gNumOf > 0) {"1\0, _objMemDesc, _memSeg, _placement"} )
    prop _objMemDesc :: ("%8t .obj: {}")
    prop _memSeg :: MEM.CFGOBJSEG
    prop _placement :: (0x7fffffff / 2)
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iComment :: if self.iDelUser == "USER" {"<add comments here>"} else {self.iDelMsg} { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "comment"
        prop JSName :: "comment"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "USER" {1} else {0}
        prop NoGen :: 1
    }
    inst iIsUsed :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iId :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iDelUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDelMsg :: "ok" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
}

type BUF {
    isa ObjectMgr
    prop name :: "BUF"
    prop Label :: "BUF - Buffer Manager"
    prop IsContainedIn :: SYSTEM
    prop GlobalIcon :: 199
    prop InstanceIcon :: 200
    prop InstanceHelpTopic :: (421)
    prop GlobalHelpTopic :: (321)
    prop InstancePropertyPage :: ("{B7240DE8-AA51-11cf-9BFE-0000C0AC14C7}")
    prop GlobalPropertyPage :: ("{B7240DE9-AA51-11cf-9BFE-0000C0AC14C7}")
    prop maxObjs :: (32767)
    prop AllocType :: (if (self.gNumOf > 0) {"1\0,      _globalAllocDesc, _memSeg, _placement"} )
    prop _globalAllocDesc :: ("%8t.buf:{}")
    prop _placement :: (0x7fffffff / 2)
    prop _memSeg :: self.OBJMEMSEG
    prop AllocInst :: ("1\0, _instAllocDesc, _instMemSeg, _placement")
    prop _instAllocDesc :: ("%8t .%0s$data: align = 0x%1x {%12t\n %0s$databeg = .;\n .+= %2d; %8t\n }\0, _objAlign, _buflength")
    prop _objAlign :: self.align
    prop _instMemSeg :: self.bufseg
    prop _buflength :: (self.postalignsize * self.bufcount)
    prop cGen :: 1
    prop cHeaderName :: if self.gNumOf > 0 {"buf.h"} else {""}
    prop cGenHInst :: (if (GBL.DSPTYPE == 62) {"extern far BUF_Obj %0r;\n\0"} else {"extern BUF_Obj %0r;\n\0"})
    prop objectSize :: (if (GBL.DSPTYPE == 62) {$a = ((7 + 3) * 4)} , if (GBL.DSPTYPE == 54 && GBL.FARMODE == 1) {$a = ((7 + 4) * 4)} , if (GBL.DSPTYPE == 54 && GBL.FARMODE == 0) {$a = ((7 + 3) * 4)} , if (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "LARGE") {$a = (12 + 6)} , if (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "HUGE") {$a = (12 + 6)} , if (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "SMALL") {$a = (7 + 4)} , if (GBL.DSPTYPE == 28) {$a = (12 + 6)} , $a)
    prop dataSize :: ($d = 0, scan ($i; BUF) {if ($i.IsConfObj()) {$d += $i.len} , $d += BUF.objectSize}, $d)
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global OBJMEMSEG :: IRAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: MEM.dataMember($1)
        prop Label :: "Object Memory"
        prop JSName :: "OBJMEMSEG"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
    }
    global ENABLED :: 1 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Compile in logging"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    inst iComment :: if self.iDelUser == "USER" {"<add comments here>"} else {self.iDelMsg} { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "comment"
        prop JSName :: "comment"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "USER" {1} else {0}
        prop NoGen :: 1
    }
    inst iIsUsed :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iId :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iDelUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDelMsg :: "ok" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst bufseg :: self.OBJMEMSEG { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: MEM.dataMember($1)
        prop Label :: "Memory segment for buffer pool"
        prop JSName :: "bufSeg"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
    }
    inst bufcount :: 1 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Buffer count"
        prop JSName :: "bufCount"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
        prop Set :: (self.bufcount = $1, self.postalignsize = (self.size + (self.align - 1)) & ~(self.align - 1), self.len = $1 * self.postalignsize, "ok")
    }
    inst size :: 8 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Buffer size (MADUs)"
        prop JSName :: "size"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
        prop Set :: (if ($1 < 8) {self.error("Size should be atleast 8 bytes")} else {self.size = $1, self.postalignsize = ($1 + (self.align - 1)) & ~(self.align - 1), self.len = self.postalignsize * self.bufcount, "ok"})
    }
    inst align :: 4 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Buffer alignment(Power of 2)"
        prop JSName :: "align"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
        prop Set :: (if ($1 < 4) {self.error("Alignment should be atleast 4 ")} else {self.align = $1, self.postalignsize = (self.size + ($1 - 1)) & ~($1 - 1), self.len = self.postalignsize * self.bufcount, "ok"})
    }
    inst len :: self.size { 
        prop Label :: "Buffer pool length (MADUs)"
        prop JSName :: "len"
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 1
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst postalignsize :: self.size { 
        prop Label :: "Buffer size after alignment (MADUs)"
        prop JSName :: "postalignsize"
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 1
        prop Writable :: 0
        prop NoGen :: 0
    }
}

type POOL {
    isa Module
    prop Visible :: 1
    prop name :: "POOL"
    prop Label :: "POOL - Allocator Manager"
    prop IsConfMod :: self.USEPOOL
    prop IsContainedIn :: SYSTEM
    prop GlobalIcon :: 199
    prop InstanceIcon :: 200
    prop GlobalHelpTopic :: (324)
    prop InstanceHelpTopic :: (424)
    prop InstancePropertyPage :: ("{473C4A62-B1A8-11d0-9885-0020AFEE33C6}")
    prop GlobalPropertyPage :: ("{473C4A63-B1A8-11d0-9885-0020AFEE33C6}")
    prop DependsOn :: "MEM,BUF"
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global USEPOOL :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Enable Allocator Manager"
        prop JSName :: "ENABLEPOOL"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
    }
}

type CLK {
    isa ObjectMgr
    prop name :: "CLK"
    prop Label :: "CLK - Clock Manager"
    prop IsContainedIn :: SCH
    prop IsConfMod :: 1
    prop GlobalIcon :: 103
    prop InstanceIcon :: 104
    prop InstanceHelpTopic :: (202)
    prop GlobalHelpTopic :: (102)
    prop InstancePropertyPage :: ("{EEB2AB41-51E3-11d0-A61D-0000C070F3E9}")
    prop GlobalPropertyPage :: ("{EEB2AB40-51E3-11d0-A61D-0000C070F3E9}")
    prop objectSize :: ($a = (1 * 4), $a)
    prop GenLinkPrologue :: ("SECTIONS {%4t\n.%1L: {\n%8t %4S \n%4t} > %3s, RUN_START(%1U_A_TABBEG) \0, name, _objSize, _memSeg, _linkString, clkFxn, _clkStartFxn")
    prop _clkStartFxn :: if (GBL.SUPPORTCSL && self.USETIMER) {@_CLK_start6x} else {@FXN_F_nop}
    prop GenLinkEpilogue :: ("%0t}\n_CLK_PRD = CLK_PRD;\n_CLK_COUNTSPMS = CLK_COUNTSPMS;\n_CLK_REGS = CLK_REGS;\n_CLK_USETIMER = CLK_USETIMER;\n_CLK_TIMERNUM = CLK_TIMERNUM;\n_CLK_TDDR = CLK_TDDR;\n\0")
    prop _linkString :: if self.gNumOf > 0 {"*(.%1L)"} else {"/* no CLK objs */"}
    prop _memSeg :: CLK.OBJMEMSEG
    prop _objSize :: self.objectSize()
    prop clkFxn :: if (self.ENABLEHTIME == 1) {self.CLKFXN} else {@FXN_F_zero}
    prop maxObjs :: (32767)
    prop SortByField :: "iPri"
    prop SortGroups :: 1
    prop localInit :: (if (GBL.CALLBACKOBJ != CLK) {CLK.gGBLChain = GBL.CALLBACKOBJ, GBL.CALLBACKOBJ = CLK} )
    prop dataSize :: (self.objectSize() * (CLK.gNumOf + 1))
    prop localCanCreate :: (if self.USETIMER {"ok"} else {self.error("The CLK Manager must be enabled before inserting a CLK")})
    prop localCreate :: (CLK.HOOKFXN = @HWI_F_dispatch, self.seizeHwi(self.WHICHHWI), "ok")
    prop localDelete :: (if (self.gNumOf == 1) {if (GBL.CALLMODEL == "far") {CLK.HOOKFXN = @CLK_F_frete, self.seizeHwi(self.WHICHHWI)} else {CLK.HOOKFXN = @CLK_F_rete, self.seizeHwi(self.WHICHHWI)}} , "ok")
    prop adjustPrd :: (if GBL.DSPTYPE == 62 {0} else {1})
    prop seizeHwi :: (if ($1.client == "USER" && $1 == HWI_UNUSED) {self.error("Interrupt not mapped for selected timer.")} else {if ($1.client == "USER" && $1.function != @HWI_unused) {self.error("Interrupt mapped to selected timer is already in use.")} else {if ($1.client == "CSL") {self.error("Interrupt mapped to selected timer is already in use by CSL.")} else {$1.function = @CLK_F_isr, $1.client = "CLK", $1.iEventId = $1.iSource.iIntrSelectNum, $1.iUseDispatcher = (if CLK.HOOKFXN == @HWI_F_dispatch {1} else {0}), $1.iArg = (if $1.iUseDispatcher == 1 {@CLK_A_TABBEG} else {0}), HWI.gDirty = 1, "ok"}}})
    prop releaseHwi :: ($1.function = @HWI_unused, $1.client = "USER", $1.iUseDispatcher = 0, $1.iArg = 0, HWI.gDirty = 1, "ok")
    prop seizeTimer :: (if ($1 == "Timer 0") {self.WHICHTIMER = "Timer 0", self.WHICHHWI = Timer_0.iHwi, self.REGS = 0x01000, self.TIMERNUM = 0, self.TIMERIMR = 0x0, self.TIMERIFR = 0x1, self.INTBIT = 4, self.TIMERIMRMASK = self.WHICHHWI.Ier0Mask, self.IMR0TINTMASK = self.WHICHHWI.Ier0Mask, self.IMR1TINTMASK = 0x0, self.setMicroseconds(self.MICROSECONDS)} else {if ($1 == "Timer 1") {self.WHICHTIMER = "Timer 1", self.WHICHHWI = Timer_1.iHwi, self.REGS = 0x2400, self.TIMERNUM = 1, self.TIMERIMR = 0x45, self.TIMERIFR = 0x46, self.INTBIT = 6, self.TIMERIMRMASK = self.WHICHHWI.Ier1Mask, self.IMR0TINTMASK = 0x0, self.IMR1TINTMASK = self.WHICHHWI.Ier1Mask, self.setMicroseconds(self.MICROSECONDS)} else {if ($1 == "Timer 2") {self.WHICHTIMER = "Timer 2", self.WHICHHWI = Timer_2.iHwi, self.REGS = 0x4000, self.TIMERNUM = 2, self.TIMERIMR = 0x0, self.TIMERIFR = 0x1, self.INTBIT = 11, self.TIMERIMRMASK = self.WHICHHWI.Ier0Mask, self.IMR0TINTMASK = self.WHICHHWI.Ier0Mask, self.IMR1TINTMASK = 0x0, self.setMicroseconds(self.MICROSECONDS)} }}, "ok")
    prop setMicroseconds :: ($a = if FIXTDDR == 1 {self.TDDR} else {0xffffffff}, $b = 0xffffffff, $c = (float($a) + 1.0) * ((float($b) + self.adjustPrd) / (CLK._INPUTCLK / 1)), if ($1 < $c && $1 > 0.1) {if (self.FIXTDDR == 0) {self.TDDR = int((1.0 * $1 * CLK._INPUTCLK / 1) / (float($b) + self.adjustPrd))} , self.PRD = int((1.0 * $1 * CLK._INPUTCLK) / (1 * (self.TDDR + 1.0))) - self.adjustPrd, self.MICROSECONDS = ((float((self.PRD)) + CLK.adjustPrd) * ((self.TDDR) + 1.0) * 1 / CLK._INPUTCLK), if (self.CALLBACKOBJ != nil) {self.CALLBACKOBJ.call()} , "ok"} else {self.error("The on-chip timer does not have enough range to support this combination of DSP MIPS and Microseconds/Int")})
    prop setInputClockRate :: (if (GBL.CLKTYPE == 6482 || GBL.CLKTYPE == 6486) {CLK._INPUTCLK = GBL.MIPS / 6} else {if (GBL.CLKTYPE == 6467 || GBL.CLKTYPE == 761990) {CLK._INPUTCLK = GBL.MIPS / 4} else {CLK._INPUTCLK = GBL.MIPS}}, "ok")
    prop call :: (if !(self.SPECIFYRATE) {self.setInputClockRate()} , $a = ((float((CLK.PRD)) + CLK.adjustPrd) * ((CLK.TDDR) + 1.0) * 1 / CLK._INPUTCLK), $b = CLK.MICROSECONDS, $e = "ok", if (($e = self.setMicroseconds(CLK.MICROSECONDS)) == "ok") {if (CLK.gGBLChain != nil) {$e = CLK.gGBLChain.call()} , if ($e != "ok") {self.setMicroseconds($b), self.error($e)} else {"ok"}} else {$e})
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gGBLChain :: nil { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global OBJMEMSEG :: IRAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: MEM.dataMember($1)
        prop Label :: "Object Memory"
        prop JSName :: "OBJMEMSEG"
        prop Visible :: 1
        prop Writable :: self.USETIMER
        prop NoGen :: 1
    }
    global WHICHHWI :: HWI_INT15 { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: HWI
        prop Label :: "CPU Interrupt"
        prop Visible :: 1
        prop Writable :: 0
        prop NoGen :: 1
    }
    global INTBIT :: = self.WHICHHWI.iIntrEnableMask
    global WHICHTIMER :: "Timer 1" { 
        prop Label :: "Timer Selection"
        prop JSName :: "TIMERSELECT"
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Timer 0,Timer 1"
        prop Visible :: 1
        prop Writable :: self.USETIMER
        prop NoGen :: 1
        prop Set :: (if (self.WHICHTIMER != $1) {if (self.USETIMER == 0) {$e = "ok"} else {if ($1 == "Timer 0") {$a = Timer_0.iHwi} else {if ($1 == "Timer 1") {$a = Timer_1.iHwi} else {$a = Timer_2.iHwi}}, $e = self.seizeHwi($a)}, if ($e == "ok") {self.releaseHwi(self.WHICHHWI), if ($1 == "Timer 0") {self.TIMERNUM = 0, self.WHICHHWI = Timer_0.iHwi} else {if ($1 == "Timer 1") {self.TIMERNUM = 1, self.WHICHHWI = Timer_1.iHwi} else {self.TIMERNUM = 2, self.WHICHHWI = Timer_2.iHwi}}, self.WHICHTIMER = $1, self.HOOKFXN = if self.gNumOf > 0 {@HWI_F_dispatch} else {(if GBL.CALLMODEL == "far" {@CLK_F_frete} else {@CLK_F_rete})}, self.seizeHwi(self.WHICHHWI)} , $e} )
    }
    global REGS :: = if self.WHICHTIMER == "Timer 0" {self.TIMER0BASE} else {self.TIMER1BASE} { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x02
        prop Visible :: 0
        prop Writable :: 1
    }
    global TIMER0BASE :: 29491200 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x02
        prop Writable :: 1
        prop Visible :: 0
        prop JSName :: "TIMER0BASE"
        prop NoGen :: 1
    }
    global TIMER1BASE :: 29495296 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x02
        prop Writable :: 1
        prop Visible :: 0
        prop JSName :: "TIMER1BASE"
        prop NoGen :: 1
    }
    global TIMERNUM :: 1 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x02
        prop NoGen :: 0
    }
    global USETIMER :: 1 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Enable CLK Manager"
        prop JSName :: "ENABLECLK"
        prop Visible :: 1
        prop Writable :: if self.gNumOf > 0 {0} else {1}
        prop NoGen :: 0
        prop Set :: (if ($1 == 1 && self.USETIMER == 0) {if (($e = self.seizeHwi(self.WHICHHWI)) == "ok") {self.USETIMER = 1, self.TIMEFXN = if CLK.HIRES {CLK.clkFxn()} else {@CLK_F_getltime}, self.HOOKFXN = if GBL.CALLMODEL == "far" {@CLK_F_frete} else {@CLK_F_rete}, self.seizeHwi(self.WHICHHWI), GlobalStatus.gDirty = 1, if (GlobalStatus.MinStackSize >= MEM.STACKSIZE) {self.releaseHwi(self.WHICHHWI), self.TIMEFXN = @FXN_F_zero, self.HOOKFXN = @FXN_F_nop, self.USETIMER = 0, GlobalStatus.gDirty = 1, self.error("Current stack size inadequate to enable CLK")} else {if (GBL.ENABLEINST == 1) {IDL_busyObj.Create("IDL"), IDL.USEIDLBUSYOBJ = 1, IDL_cpuLoad.Create("IDL"), IDL.AUTOCALCULATE = GBL.OLDAUTOCALCULATE} , $e}} else {$e}} else {if ($1 == 0 && self.USETIMER == 1) {self.releaseHwi(self.WHICHHWI), self.TIMEFXN = @FXN_F_zero, self.HOOKFXN = @FXN_F_nop, self.USETIMER = 0, if (GBL.ENABLEINST == 1) {IDL_busyObj.Delete("IDL"), IDL.USEIDLBUSYOBJ = 0, IDL_cpuLoad.Delete("IDL"), GBL.OLDAUTOCALCULATE = IDL.AUTOCALCULATE, IDL.AUTOCALCULATE = 0} , "ok"} else {"ok"}})
    }
    global HIRES :: = 1 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Use high resolution time for internal timings"
        prop JSName :: "HIRESTIME"
        prop Visible :: 1
        prop Writable :: self.USETIMER
        prop NoGen :: 1
        prop Set :: (if (CLK.USETIMER) {CLK.HIRES = $1, if (CLK.USETIMER) {CLK.TIMEFXN = if CLK.HIRES {CLK.clkFxn()} else {@CLK_F_getltime}} , "ok"} else {self.error("CLK Manager must be enabled in order to get high resolution timings.")})
    }
    global ENABLEHTIME :: = 1 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Enable high resolution timer"
        prop JSName :: "ENABLEHTIME"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
    }
    global INSTRPERCLK :: 1 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global SPECIFYRATE :: 1 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Specify input clock rate"
        prop JSName :: "SPECIFYRATE"
        prop Visible :: 1
        prop Writable :: self.USETIMER
        prop NoGen :: 1
        prop Set :: ($e = "ok", $a = self.SPECIFYRATE, self.SPECIFYRATE = $1, if !(self.SPECIFYRATE) {$e = CLK.call(), if ($e != "ok") {self.SPECIFYRATE = $a, CLK.call()} } , $e)
    }
    global _INPUTCLK :: 24.000000 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Style :: 0x04
        prop Format :: "%.4f"
        prop Label :: "Input frequency (MHz)"
        prop JSName :: "INPUTCLK"
        prop Visible :: 1
        prop Writable :: self.USETIMER && self.SPECIFYRATE
        prop NoGen :: 1
        prop Set :: ($e = "ok", $a = self._INPUTCLK, self._INPUTCLK = $1, $e = CLK.call(), if ($e != "ok") {self._INPUTCLK = $a, CLK.call()} , $e)
    }
    global _RESETTIMER :: 1 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Reset Timer and TIMMODE"
        prop JSName :: "RESETTIMER"
        prop Visible :: 1
        prop Writable :: self.USETIMER
        prop NoGen :: 1
    }
    global _TIMMODE :: "32-bit unchained" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "32-bit unchained,32-bit chained,externally programmed"
        prop Label :: "Timer Mode"
        prop JSName :: "TIMMODE"
        prop Visible :: 1
        prop Writable :: self.USETIMER
        prop NoGen :: 1
    }
    global MICROSECONDS :: 1000.000000 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Style :: 0x04
        prop Format :: "%.4f"
        prop Label :: "Microseconds/Int"
        prop JSName :: "MICROSECONDS"
        prop Set :: (self.setMicroseconds($1))
        prop Visible :: 1
        prop Writable :: if ((CLK.PROGTIMREGS != 0) | (self.USETIMER == 0)) {0} else {1}
        prop NoGen :: 1
    }
    global MICROSECS :: = int(round(self.MICROSECONDS)) { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x20
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    global PROGTIMREGS :: = 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Directly configure on-chip timer registers"
        prop JSName :: "CONFIGURETIMER"
        prop Visible :: 1
        prop Writable :: self.USETIMER
        prop NoGen :: 1
    }
    global TCR :: = 0x20 | CLK.TDDR { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    global FIXTDDR :: 1 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Fix TDDR"
        prop JSName :: "FIXTDDR"
        prop Visible :: (GBL.DSPTYPE != 62)
        prop Writable :: CLK.PROGTIMREGS && (GBL.DSPTYPE != 62)
        prop NoGen :: 1
    }
    global TDDR :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x20
        prop Label :: "TDDR Register"
        prop JSName :: "TCRTDDR"
        prop Set :: (if ((GBL.DSPTYPE != 62) && ($1 > 0xffffffff)) {self.error("The on-chip timer does not have enough range to support this value, maximum is 15.")} else {CLK.TDDR = $1, CLK.MICROSECONDS = ((float((CLK.PRD)) + CLK.adjustPrd) * ((CLK.TDDR) + 1.0) * 1 / CLK._INPUTCLK), if (CLK.CALLBACKOBJ != nil) {CLK.CALLBACKOBJ.call()} , "ok"})
        prop Visible :: GBL.DSPTYPE != 62
        prop Writable :: CLK.PROGTIMREGS && GBL.DSPTYPE != 62
        prop NoGen :: 0
    }
    global TDDRHIGH :: = ((self.TDDR & 0xffff0000) >> 16) { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
    }
    global PRD :: 24000 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x20
        prop Label :: if (GBL.CLKTYPE == 700) {"Compare0 Register"} else {"PRD Register"}
        prop JSName :: "PRD"
        prop Set :: (CLK.PRD = $1, CLK.MICROSECONDS = ((float((CLK.PRD)) + CLK.adjustPrd) * ((CLK.TDDR) + 1.0) * 1 / CLK._INPUTCLK), if (CLK.CALLBACKOBJ != nil) {CLK.CALLBACKOBJ.call()} , "ok")
        prop Visible :: 1
        prop Writable :: if ((self.PROGTIMREGS) && (self.USETIMER)) {1} else {0}
        prop NoGen :: 0
    }
    global PRDHIGH :: = ((self.PRD & 0xffff0000) >> 16) { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
    }
    global COUNTSPMS :: = int(round(GBL.MIPS * 1000.0 / (CLK.TDDR + 1) / 1)) { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x20
    }
    global COUNTSPMSHIGH :: = ((self.COUNTSPMS & 0xffff0000) >> 16) { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
    }
    global INSTRUCTIONS :: = (1.0 * (float(CLK.PRD) + CLK.adjustPrd) * (CLK.TDDR + 1.0) * 1) { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Style :: 0x04
        prop Format :: "%.0f"
        prop Label :: "Instructions/Int"
        prop Visible :: 1
        prop Writable :: 0
        prop NoGen :: 1
    }
    global TIMEFXN :: = CLK.clkFxn() { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    global HOOKFXN :: @HWI_F_dispatch { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    global CLKFXN :: = @_CLK_gethtime { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global CALLBACKOBJ :: PRD { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global CALDIV :: = 1 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x20
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    global CALMULT :: = 1 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x20
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    global HTIMEDIV :: = 1 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x20
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    global HTIMEMULT :: = 1 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x20
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    global LTIMEDIV :: = 1 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x20
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    global LTIMEMULT :: = int((self.TDDR + 1) * (self.PRD + self.adjustPrd) * (GBL.MIPS / CLK._INPUTCLK)) { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x20
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    global INPUTCLK :: = int(round(self._INPUTCLK * 1000)) { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x20
        prop JSName :: ""
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    global RESETTIMER :: = (self._RESETTIMER) { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop JSName :: ""
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    global TIMMODE :: = (if self._TIMMODE == "32-bit unchained" {0x5} else {if self._TIMMODE == "32-bit chained" {0xF} else {0}}) { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop JSName :: ""
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    global HTIMEPERLTIME :: = int(round(GBL.MIPS * self.MICROSECONDS)) { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x20
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    inst iComment :: if self.iDelUser == "USER" {"<add comments here>"} else {self.iDelMsg} { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "comment"
        prop JSName :: "comment"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "USER" {1} else {0}
        prop NoGen :: 1
    }
    inst iIsUsed :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iId :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iDelUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDelMsg :: "ok" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst function :: @FXN_F_nop { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "function"
        prop JSName :: "fxn"
        prop Visible :: 1
        prop Writable :: (if self.iDelUser == "USER" {1} else {0})
        prop NoGen :: 0
    }
    inst Order :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop JSName :: "order"
        prop NoGen :: 1
        prop Writable :: 1
    }
    inst iPri :: 0 { 
        prop Type :: "{A11FE980-C07A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop NoGen :: 1
    }
}

type PRD {
    isa ObjectMgr
    prop name :: "PRD"
    prop Label :: "PRD - Periodic Function Manager"
    prop IsContainedIn :: SCH
    prop IsConfMod :: 1
    prop GlobalIcon :: 119
    prop InstanceIcon :: 120
    prop InstanceHelpTopic :: (210)
    prop GlobalHelpTopic :: (110)
    prop InstancePropertyPage :: ("{B7240DE0-AA51-11cf-9BFE-0000C0AC14C7}")
    prop GlobalPropertyPage :: ("{B7240DE1-AA51-11cf-9BFE-0000C0AC14C7}")
    prop STSGetMaxFmt :: ("%g ticks")
    prop STSGetSumFmt :: (PRD.STSGetMaxFmt())
    prop STSGetAvgFmt :: ("%.2f ticks")
    prop GetPeriod :: self.period
    prop IsOneShot :: if self.mode == "one-shot" {1} else {0}
    prop objectSize :: (if (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "SMALL") {$a = (10 * 4)} , if (GBL.DSPTYPE == 54 && GBL.FARMODE == 0) {$a = (9 * 4)} , if (GBL.DSPTYPE == 54 && GBL.FARMODE == 1) {$a = (12 * 4)} , if (GBL.DSPTYPE == 28 || (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "LARGE") || (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "HUGE")) {$a = (12 * 4)} , if (GBL.DSPTYPE == 62) {$a = (8 * 4)} , $a)
    prop GenLinkPrologue :: ("SECTIONS {%4t\n.prd: RUN_START(PRD_A_TABBEG), RUN_END(PRD_A_TABEND) {%4t\n} > %1s%2s\0, memSeg, pageString")
    prop GenLinkEpilogue :: ("%0t}\nPRD_A_TABLEN = %1d;\n\0, numInst")
    prop linkString :: if self.gNumOf > 0 {"*(.%1L)"} else {"/* no %1U objects */"}
    prop pageString :: if GBL.DSPTYPE == 62 {""} else {if (GBL.DSPTYPE == 55 || GBL.DSPTYPE == 28) {(if PRD.OBJMEMSEG.space() == "code" {" PAGE 0"} else {if PRD.OBJMEMSEG.space() == "data" {" PAGE 1"} else {if PRD.OBJMEMSEG.space() == "io" {" PAGE 2"} else {" PAGE 0"}}})} else {" PAGE 1"}}
    prop memSeg :: PRD.OBJMEMSEG
    prop objSize :: if GBL.DSPTYPE == 55 {self.objectSize() * 2} else {self.objectSize()}
    prop numInst :: (PRD.gNumOf)
    prop dataSize :: (self.objectSize() * PRD.gNumOf)
    prop localInit :: (if (CLK.CALLBACKOBJ != nil) {self.error("PRD initialization failure")} , CLK.CALLBACKOBJ = PRD, if (PRD.USECLK && PRD_clock.iIsUsed == 0) {PRD_clock.Create("PRD")} , if (PRD_clock.iIsUsed == 1) {if (self.gNumOf == 0) {if (TSK.USETSK == 1 && TSK.TSKTICK == "PRD") {PRD_clock.function = @PRD_F_tick} else {PRD_clock.function = @FXN_F_nop}} else {PRD_clock.function = @PRD_F_tick}} )
    prop localCanCreate :: (if (GlobalStatus.MinStackSize >= MEM.STACKSIZE) {self.error(" System Stack Size too small")} else {self.myCreate("can")})
    prop localCreate :: (STS.gNumEmbed += 1, if (($a = self.myCreate("do")) == "ok") {if (PRD_clock.iIsUsed == 1) {if (self.gNumOf == 0) {PRD_clock.function = @PRD_F_tick} } } , $a)
    prop localCanDelete :: (self.myDelete("can"))
    prop localDelete :: (STS.gNumEmbed -= 1, if (($a = self.myDelete("do")) == "ok") {if (self.gNumOf == 1) {if (PRD_clock.iIsUsed == 1) {if (TSK.USETSK == 1 && TSK.TSKTICK == "PRD") {PRD_clock.function = @PRD_F_tick} else {PRD_clock.function = @FXN_F_nop}} } } , $a)
    prop maxObjs :: (32767)
    prop myCreate :: (if (PRD_swi.function != @PRD_F_swi) {PRD_swi.function = @PRD_F_swi} , if (PRD_swi.iIsUsed) {"ok"} else {if (SWI.CanCreate() == "ok") {if ($1 == "do") {if (KNL_swi.iIsUsed == 1 && PRD_swi.pri == 0) {PRD_swi.pri = 1} , PRD_swi.Create("PRD")} else {"ok"}} else {self.error("Can't create an SWI for PRD (try deleting a SWI)")}})
    prop myDelete :: (if (PRD_swi.function != @PRD_F_swi) {PRD_swi.function = @PRD_F_swi} , if (self.gNumOf == 1) {if ($1 == "do") {PRD_swi.Delete("PRD")} else {"ok"}} else {"ok"})
    prop call :: (if (CLK.USETIMER != 0) {PRD.MICROSECONDS = CLK.MICROSECONDS} , PRD.CALLBACKOBJ.call())
    prop cGen :: 1
    prop cHeaderName :: if self.gNumOf > 0 {"prd.h"} else {""}
    prop cGenHInst :: (if (GBL.DSPTYPE == 62) {"extern far PRD_Obj %0r;\n\0"} else {"extern PRD_Obj %0r;\n\0"})
    prop SortByField :: "iPri"
    prop SortGroups :: 1
    prop DEFAULT_THOOKFXN :: @_KNL_tick
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global OBJMEMSEG :: IRAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: MEM.dataMember($1)
        prop Label :: "Object Memory"
        prop JSName :: "OBJMEMSEG"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
    }
    global USECLK :: 1 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Use CLK Manager to drive PRD"
        prop JSName :: "USECLK"
        prop Visible :: 1
        prop Writable :: 1
        prop Set :: (if ($1 == 1 && self.USECLK == 0) {if (CLK.USETIMER == 0) {self.error("In order to drive periodic functions, the CLK Manager must be enabled")} else {self.USECLK = 1, self.MICROSECONDS = CLK.MICROSECONDS, CLK.CALLBACKOBJ = PRD, PRD_clock.Create("PRD"), GlobalStatus.gDirty = 1, if (GlobalStatus.MinStackSize >= MEM.STACKSIZE) {self.USECLK = 0, self.MICROSECONDS = 0.0, CLK.CALLBACKOBJ = nil, PRD_clock.Delete("PRD"), self.error("Current Stack size inadequate to enable this option")} else {"ok"}}} else {if ($1 == 0 && self.USECLK == 1) {self.USECLK = 0, self.MICROSECONDS = 0.0, CLK.CALLBACKOBJ = nil, PRD_clock.Delete("PRD")} , "ok"})
        prop NoGen :: 1
    }
    global MICROSECONDS :: 1000.000000 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Style :: 0x04
        prop Format :: "%.1f"
        prop Label :: "Microseconds/Tick"
        prop JSName :: "MICROSECONDS"
        prop Visible :: 1
        prop Writable :: self.USECLK == 0
        prop NoGen :: 1
    }
    global SCALAR :: = ($d = 2, $f = 0, while ($d <= 0x4000 && $f == 0) {scan ($i; PRD) {if ((($i.period / $d) * $d != $i.period)) || ($i.mode == "one-shot") {$f = 1} }, if ($f == 0) {$d = 2 * $d} }, $d / 2) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    global THOOKFXN :: @_KNL_tick { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "System Tick Hook Function"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 0
    }
    global CALLBACKOBJ :: STS { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iComment :: if self.iDelUser == "USER" {"<add comments here>"} else {self.iDelMsg} { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "comment"
        prop JSName :: "comment"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "USER" {1} else {0}
        prop NoGen :: 1
    }
    inst iIsUsed :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iId :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iDelUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDelMsg :: "ok" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst period :: 0x7fff { 
        prop Label :: "period (ticks)"
        prop JSName :: "period"
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
        prop Set :: (if (($1 > 0) && ($1 < 0x8000)) {self.period = $1, self.gDirty = 1, "ok"} else {self.error("Periodic function periods must be greater than 0 and less than 0x8000")})
    }
    inst mode :: "continuous" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "continuous,one-shot"
        prop JSName :: "mode"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
    }
    inst function :: @FXN_F_nop { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop JSName :: "fxn"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
    }
    inst arg0 :: 0 { 
        prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
        prop JSName :: "arg0"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
    }
    inst arg1 :: 0 { 
        prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
        prop JSName :: "arg1"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
    }
    inst milliseconds :: = ((self.period * PRD.MICROSECONDS) / 1000.0) { 
        prop Label :: "period (ms)"
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Style :: 0x04
        prop Format :: "%.1f"
        prop Visible :: 1
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst Order :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop JSName :: "order"
        prop NoGen :: 0
        prop Writable :: 1
    }
    inst iPri :: 0 { 
        prop Type :: "{A11FE980-C07A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop NoGen :: 1
    }
    inst filter :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 1
        prop Label :: "filter"
        prop NoGen :: 0
    }
    inst maxformat :: "%g ticks" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 1
        prop Label :: "maxformat"
        prop NoGen :: 0
    }
    inst sumformat :: "%g ticks" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 1
        prop Label :: "sumformat"
        prop NoGen :: 0
    }
    inst avgformat :: "%.2f ticks" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 1
        prop Label :: "avgformat"
        prop NoGen :: 0
    }
    inst unittype :: 2 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 1
        prop Label :: "unittype"
        prop NoGen :: 0
    }
}

object PRD_swi :: SWI {
    param iComment :: "This Software ISR executes all configured PRD functions"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "PRD"
    param iDelMsg :: "This object is automatically deleted when all PRD objects are deleted"
    param function :: @PRD_F_swi
    param pri :: 1
    param mailbox :: 0
    param arg0 :: 0
    param arg1 :: 0
    param dorta :: 1
    param Order :: 0
    param filter :: 2
    param maxformat :: "%g inst"
    param sumformat :: "%g inst"
    param avgformat :: "%.2f inst"
    param filtmaxmult :: 1
    param filtsummult :: 1
    param unittype :: 0
}

object PRD_clock :: CLK {
    param iComment :: "This clock function calls PRD_tick from within the on-chip timer ISR"
    param iIsUsed :: 1
    param iId :: 0
    param iDelUser :: "PRD"
    param iDelMsg :: "This object is automatically deleted by disabling the 'Use CLK Manager to drive PRD' option of PRD"
    param function :: @PRD_F_tick
    param Order :: 0
    param iPri :: 0
}

type RTDX {
    isa ObjectMgr
    prop Label :: "RTDX - Real-Time Data Exchange Settings"
    prop name :: "RTDX"
    prop IsConfMod :: self.USERTDX
    prop IsContainedIn :: IOF
    prop GlobalIcon :: 145
    prop InstanceIcon :: 146
    prop GlobalHelpTopic :: (113)
    prop InstanceHelpTopic :: (213)
    prop InstancePropertyPage :: ("{f80273c0-3838-11d2-a32c-006097656921}")
    prop GlobalPropertyPage :: ("{050a0600-3839-11d2-a32c-006097656921}")
    prop AllocType :: (if self.USERTDX {"2\0, _rtdxDataAllocDesc, _rtdxDataSeg, _placement,
	     _rtdxTextAllocDesc, _rtdxTextSeg, _placement"} else {""})
    prop _rtdxDataAllocDesc :: (" .%1L_data: align = 0x40 { . += 0x80; *(.rtdx_data) }  \0, name")
    prop _rtdxTextAllocDesc :: (if (MEM.ENABLELOADSEG == 1) {if (MEM.RTDXTEXTMEMSEG == MEM.LOADRTDXTEXTMEMSEG) {" .%1L_text: {} \0, name"} else {" .%1L_text: {} load > %2s, run \0, name, _loadRtdxTextMemSeg"}} else {" .%1L_text: {} \0, name"})
    prop _rtdxDataSeg :: RTDX.DATAMEMSEG
    prop _rtdxTextSeg :: MEM.RTDXTEXTMEMSEG
    prop _loadRtdxTextMemSeg :: MEM.LOADRTDXTEXTMEMSEG
    prop _placement :: (0x7fffffff / 2)
    prop _objSize :: RTDX.BUFMEMSIZE
    prop GenLinkPrologue :: (if self.USERTDX {"_RTDX_interrupt_mask = 0x%1x;\n\0, _interruptMask"} else {""})
    prop _interruptMask :: RTDX.MASK
    prop cGen :: 1
    prop noObjectAlias :: 1
    prop cHeaderName :: if self.gNumOf > 0 {"rtdx.h"} else {""}
    prop cGenHInst :: (if (GBL.DSPTYPE == 62) {if (self.iChannelMode == "output") {"extern far RTDX_outputChannel %0r;\n\0"} else {"extern far RTDX_inputChannel %0r;\n\0"}} else {if (self.iChannelMode == "output") {"extern RTDX_outputChannel %0r;\n\0"} else {"extern RTDX_inputChannel %0r;\n\0"}})
    prop cGenCInst :: (if (self.iChannelMode == "output") {"RTDX_CreateOutputChannel(%0r);\n\0"} else {"RTDX_CreateInputChannel(%0r);\n\0"})
    prop dataSize :: ($d = 0, if (self.USERTDX) {$d = RTDX.BUFMEMSIZE} else {$d = 0}, scan ($a; RTDX) {if ($a.iChannelMode == "output") {$d += 1} else {$d += 3}}, $d)
    prop localCanCreate :: ($e = "ok", if (RTDX.USERTDX != 1) {$e = self.error("RTDX manager not enabled")} , $e)
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global USERTDX :: 1 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Enable Real-Time Data Exchange (RTDX)"
        prop JSName :: "ENABLERTDX"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
        prop Set :: (if ($1 == 0) {if (HST.LNKTYPE == "RTDX") {self.error("RTDX is being used by HST; select a different host link type before attempting to disable RTDX")} else {if (self.gNumOf > 0) {self.error("Cannot disable RTDX until all RTDX objects are deleted.")} else {GlobalStatus.gDirty = 1, self.USERTDX = $1, if (RTDX.CALLBACKOBJ != nil) {RTDX.CALLBACKOBJ.call()} , "ok"}}} else {GlobalStatus.gDirty = 1, self.USERTDX = $1, if (RTDX.CALLBACKOBJ != nil) {RTDX.CALLBACKOBJ.call()} , "ok"})
    }
    global USERTEXECUTION :: = 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Enable Real-Time Execution Control"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    global RTDXTYPE :: "JTAG" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "JTAG,HSRTDX,Simulator"
        prop Label :: "RTDX Mode"
        prop JSName :: "MODE"
        prop Visible :: 1
        prop Writable :: self.USERTDX
        prop NoGen :: 0
        prop Set :: (self.RTDXTYPE = $1, if (RTDX.CALLBACKOBJ != nil) {RTDX.CALLBACKOBJ.call()} , "ok")
    }
    global DATAMEMSEG :: IRAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: MEM.dataMember($1)
        prop Label :: "RTDX Data Segment (.rtdx_data)"
        prop JSName :: "RTDXDATASEG"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
    }
    global BUFMEMSIZE :: = (256 + 2) * (GBL.DSPWORDSIZE / GBL.DSPCHARSIZE) { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x02
        prop Label :: "RTDX Buffer Size (MAUs)"
        prop JSName :: "BUFSIZE"
        prop Visible :: 1
        prop Writable :: self.USERTDX
        prop NoGen :: 0
        prop Set :: (if (HST.RTDX == 0) {self.BUFMEMSIZE = $1, GlobalStatus.gDirty = 1, "ok"} else {if ($1 < (HST.MAXFRAMESET + 3) * (GBL.DSPWORDSIZE / GBL.DSPCHARSIZE)) {self.error("size (in MAUs) must be at least: (largest configured HST channel framesize in words + 3) * (MAUs per word)")} else {self.BUFMEMSIZE = $1, GlobalStatus.gDirty = 1, if (HST.LNKTYPE == "RTDX") {HST.MAXFRAMEALLOWED = (self.BUFMEMSIZE / (GBL.DSPWORDSIZE / GBL.DSPCHARSIZE)) - 3, "ok"} else {"ok"}}})
    }
    global TEXTMEMSEG :: DDR { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: MEM.codeMember($1)
        prop Label :: "RTDX Text Segment (.rtdx_text)"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    global MASK :: 0 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%08x"
        prop Style :: 0x02
        prop Label :: "RTDX Interrupt Mask"
        prop JSName :: "INTERRUPTMASK"
        prop Visible :: 1
        prop Writable :: self.USERTDX
        prop NoGen :: 1
        prop Set :: (self.MASK = $1, "ok")
    }
    global CALLBACKOBJ :: HWI { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iComment :: if self.iDelUser == "USER" {"<add comments here>"} else {self.iDelMsg} { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "comment"
        prop JSName :: "comment"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "USER" {1} else {0}
        prop NoGen :: 1
    }
    inst iIsUsed :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iId :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iDelUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDelMsg :: "ok" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iChannelMode :: "output" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Channel Mode"
        prop JSName :: "channelMode"
        prop Enum :: "input,output"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
        prop Set :: (GlobalStatus.gDirty = 1, self.iChannelMode = $1, "ok")
    }
}

type HST {
    isa ObjectMgr
    prop name :: "HST"
    prop Label :: "HST - Host Channel Manager"
    prop IsContainedIn :: IOF
    prop DependsOn :: "HWI"
    prop FileStream :: 1
    prop GlobalIcon :: 107
    prop InstanceIcon :: 108
    prop GlobalHelpTopic :: (104)
    prop InstanceHelpTopic :: (204)
    prop maxObjs :: (GBL.DSPWORDSIZE)
    prop dataSize :: ($b = 0, scan ($i; HST) {if ($i.IsConfObj()) {$b += (12 + $i.framesize) * $i.numframes + PIP.OBJSIZE + self.objectSize()} }, $b)
    prop InstancePropertyPage :: ("{B7240DEA-AA51-11cf-9BFE-0000C0AC14C8}")
    prop GlobalPropertyPage :: ("{B7240DEB-AA51-11cf-9BFE-0000C0AC14C8}")
    prop localCreate :: (PIP.gNumEmbed += 1, if (self.gNumOf == 0) {(LNK_dataPump.Create("HST"))} , "ok")
    prop localDelete :: (PIP.gNumEmbed -= 1, $b = 0, scan ($i; HST) {if ($i != self) {if ($i.IsConfObj()) {if ($i.framesize > $b) {$b = $i.framesize} } } }, self.MAXFRAMESET = $b, if (self.gNumOf == 1) {(LNK_dataPump.Delete("HST"))} , "ok")
    prop GenLinkPrologue :: (if (self.LNKTYPE == "RTDX") {"_LNK_dspFrameReadyMask = LNK_dspFrameReadyMask; \n_LNK_dspFrameRequestMask = LNK_dspFrameRequestMask; \n_LNK_readDone = LNK_readDone; \n_LNK_readFail = LNK_readFail; \n_LNK_readPend = LNK_readPend; \n_LNK_writeFail = LNK_writeFail;"} )
    prop AllocType :: ("2\0, _globalAllocDesc, _memSeg, _placement, 	      _dsmAllocDesc, _dsmMemSeg, _placement")
    prop _globalAllocDesc :: ("%8t .%1L: RUN_START(%1U_A_TABBEG), RUN_START(_%1U_A_TABBEG), RUN_END(%1U_A_TABEND), RUN_END(_%1U_A_TABEND) {%8t\n }\0, name")
    prop objectSize :: (if (GBL.DSPTYPE == 28) {$a = (14 * 4)} , if (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "LARGE") {$a = (12 * 4)} , if (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "HUGE") {$a = (12 * 4)} , if (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "SMALL") {$a = (10 * 4)} , if (GBL.DSPTYPE == 54 || GBL.DSPTYPE == 62) {$a = (7 * 4)} , $a)
    prop _dsmAllocDesc :: ("%8t .dsm: {}")
    prop _placement :: (0x7fffffff / 2)
    prop AllocInst :: ("1\0, _instAllocDesc, _objMemSeg, _placement")
    prop _instAllocDesc :: (if RTDX.RTDXTYPE == "Simulator" {"/* %0s buffer */\n.hst%2d: align = 0x40 { . += 0x80; *(.hst%2d) } \0, name, _objId"} else {"/* %0s buffer */\n.hst%2d: %3S\0, name, _objId, _alignString, _objAlign"})
    prop _alignString :: if self.bufalign > 1 {"align = 0x%4x {}"} else {""}
    prop _objId :: self.iId
    prop _objAlign :: self.bufalign
    prop _objMemSeg :: self.bufseg
    prop _linkString :: if (self.gNumOf + self.gNumEmbed) > 0 {"*(.%1L)"} else {"/* no %1U objects */"}
    prop _memSeg :: HST.OBJMEMSEG
    prop _dsmMemSeg :: HST.DSMBUFSEG
    prop _objSize :: if GBL.DSPTYPE == 55 {(2 * self.objectSize())} else {self.objectSize()}
    prop cGen :: 1
    prop cHeaderName :: if self.gNumOf > 0 {"hst.h"} else {""}
    prop cGenHInst :: (if (GBL.DSPTYPE == 62) {"extern far HST_Obj %0r;\n\0"} else {"extern HST_Obj %0r;\n\0"})
    prop modifiable :: ((if self.iDelUser == "USER" {1} else {0}))
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 3 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 2 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumEmbed :: 0 { 
        prop NoGen :: 1
    }
    global OBJMEMSEG :: IRAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: MEM.dataMember($1)
        prop Label :: "Object Memory"
        prop JSName :: "OBJMEMSEG"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
    }
    global LNKTYPE :: "RTDX" { 
        prop Label :: "Host Link Type"
        prop JSName :: "HOSTLINKTYPE"
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "RTDX,BIOSLINK,NONE"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
        prop Set :: (if ($1 == "RTDX") {if (RTDX.USERTDX == 0) {self.error("RTDX module must be enabled before it can be used by HST")} else {if ((RTDX.BUFMEMSIZE / (GBL.DSPWORDSIZE / GBL.DSPCHARSIZE)) - 2 < self.MAXFRAMESET) {self.error("RTDX buffer size too small for largest configured HST channel")} else {if (self.LNKTYPE == "NONE") {GlobalStatus.gDirty = 1, self.LNKTYPE = $1, $b = 0, scan ($i; HST) {if ($i.IsConfObj()) {if ($i.framesize > $b) {$b = $i.framesize} } }, self.MAXFRAMESET = $b, self.MAXFRAMEALLOWED = (RTDX.BUFMEMSIZE / (GBL.DSPWORDSIZE / GBL.DSPCHARSIZE)) - 3, "ok"} else {self.LNKTYPE = $1, self.MAXFRAMEALLOWED = (RTDX.BUFMEMSIZE / (GBL.DSPWORDSIZE / GBL.DSPCHARSIZE)) - 3, "ok"}}}} else {if ($1 == "Shared Memory") {if ((self.DSMMEMSIZE / 4) < self.MAXFRAMESET) {self.error("Shared memory buffer too small for largest configured HST channel")} else {if (self.LNKTYPE == "NONE") {GlobalStatus.gDirty = 1, self.LNKTYPE = $1, $b = 0, scan ($i; HST) {if ($i.IsConfObj()) {if ($i.framesize > $b) {$b = $i.framesize} } }, self.MAXFRAMESET = $b, self.MAXFRAMEALLOWED = self.DSMMEMSIZE / 4, "ok"} else {self.LNKTYPE = $1, self.MAXFRAMEALLOWED = self.DSMMEMSIZE / 4, "ok"}}} else {GlobalStatus.gDirty = 1, self.LNKTYPE = $1, "ok"}})
    }
    global RTDX :: = if self.LNKTYPE == "RTDX" {1} else {0} { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Use RTDX for host link"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    global DSM :: = if self.LNKTYPE == "Shared Memory" {1} else {0} { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Use Shared Memory for host link"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    global EVM54 :: = if self.LNKTYPE == "EVM54" {1} else {0} { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Use EVM54's I/O ports for host link"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global NONE :: = if self.LNKTYPE == "NONE" {1} else {0} { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "No host link"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    global MAXFRAMESET :: 64 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "MAXFRAMESET"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 0
    }
    global MAXFRAMEALLOWED :: 255 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "MAXFRAMEALLOWED"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 0
    }
    global DSMBUFSEG :: = self.OBJMEMSEG { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: MEM.dataMember($1)
        prop Label :: "Shared Memory Segment"
        prop Visible :: 0
        prop Writable :: self.DSM
        prop NoGen :: 0
    }
    global DSMMEMSIZE :: = 1024 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop Label :: "Shared Memory Frame Size (MAUs)"
        prop Visible :: 0
        prop Writable :: self.DSM
        prop NoGen :: 0
        prop Set :: (if ($1 < HST.MAXFRAMESET * 4) {self.error("size (in MAUs) must be at least: 4 * largest configured HST channel framesize (in words)")} else {self.DSMMEMSIZE = $1, GlobalStatus.gDirty = 1, if (self.LNKTYPE == "Shared Memory") {self.MAXFRAMEALLOWED = self.DSMMEMSIZE / 4, "ok"} else {"ok"}})
    }
    inst iComment :: if self.iDelUser == "USER" {"<add comments here>"} else {self.iDelMsg} { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "comment"
        prop JSName :: "comment"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "USER" {1} else {0}
        prop NoGen :: 1
    }
    inst iIsUsed :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iId :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iDelUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDelMsg :: "ok" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst mode :: "output" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop JSName :: "mode"
        prop Enum :: "input,output"
        prop Visible :: 1
        prop Writable :: self.modifiable()
        prop NoGen :: 0
    }
    inst bufseg :: = self.OBJMEMSEG { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "bufseg"
        prop JSName :: "bufSeg"
        prop MemberType :: MEM
        prop MemberTest :: MEM.dataNullMember($1)
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst bufalign :: 4 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop JSName :: "bufAlign"
        prop Visible :: 1
        prop Writable :: self.modifiable()
        prop NoGen :: 1
        prop Set :: (if ($1 < 4) {self.error("Alignment must be greater than or equal to 4")} else {if (($1 % 2) != 0) {self.error("Alignment must be a power of 2")} else {$i = $1, while ((($i % 2) == 0) && ($i != 2)) {$i = $i / 2}, if (($i % 2) != 0) {self.error("Alignment must be a power of 2")} else {self.bufalign = $1, "ok"}}})
    }
    inst buf :: "<NULL>" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    inst framesize :: 0x80 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "framesize (words)"
        prop JSName :: "frameSize"
        prop Style :: 0x01 | 0x02
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
        prop Set :: (if ($1 < 1) {self.error("framesize must be >= 1.")} else {if (($1 > self.MAXFRAMEALLOWED) && ((self.RTDX == 1) || (self.DSM == 1))) {if (self.RTDX == 1) {self.error("size (in words) is limited to: (RTDX buffer size in MAUs) / (MAUs per word) - 3")} else {self.error("size (in words) is limited to: shared memory frame size (in MAUs)/4")}} else {self.framesize = $1, $b = 0, scan ($i; HST) {if ($i.IsConfObj()) {if ($i.framesize > $b) {$b = $i.framesize} } }, self.MAXFRAMESET = $b, GlobalStatus.gDirty = 1, "ok"}})
    }
    inst numframes :: 2 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop JSName :: "numFrames"
        prop Visible :: 1
        prop Writable :: self.modifiable()
        prop NoGen :: 0
        prop Set :: (if ($1 < 1) {self.error("Channels must contain at least 1 frame.")} else {GlobalStatus.gDirty = 1, self.numframes = $1, "ok"})
    }
    inst stsflg :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "statistics"
        prop JSName :: "statistics"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
    }
    inst notify :: @_FXN_F_nop { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop JSName :: "notifyFxn"
        prop Visible :: 1
        prop Writable :: (if self.iDelUser == "DHL" || self.iDelUser != "USER" {0} else {1})
        prop NoGen :: 0
        prop TabName :: "Notify Function"
    }
    inst arg0 :: 0 { 
        prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
        prop JSName :: "arg0"
        prop Visible :: 1
        prop Writable :: (if self.iDelUser == "DHL" || self.iDelUser != "USER" {0} else {1})
        prop NoGen :: 0
        prop TabName :: "Notify Function"
    }
    inst arg1 :: 0 { 
        prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
        prop JSName :: "arg1"
        prop Visible :: 1
        prop Writable :: (if self.iDelUser == "DHL" || self.iDelUser != "USER" {0} else {1})
        prop NoGen :: 0
        prop TabName :: "Notify Function"
    }
    inst lnk :: = if self.RTDX {"RTDX"} else {"NOTRTDX"} { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "link type"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    inst iDHLAvailable :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Make this channel available for a new DHL device"
        prop JSName :: "availableForDHL"
        prop Set :: (if (($1 == 0) && (self.iDHLAvailable == 1)) {DHL.gChannelsAvailable--} else {if (($1 == 1) && (self.iDHLAvailable == 0)) {DHL.gChannelsAvailable++} }, self.iDHLAvailable = $1, "ok")
        prop Writable :: self.modifiable()
        prop Visible :: 1
        prop NoGen :: 1
    }
    inst bufFrameAlign :: = self.bufalign { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
}

object LNK_dataPump :: IDL {
    param iComment :: "This object cannot be deleted"
    param iIsUsed :: 1
    param iId :: 0
    param iDelUser :: "HST"
    param iDelMsg :: "This object cannot be deleted"
    param function :: @LNK_F_dataPump
    param cycles :: 0
    param calibration :: 1
    param Order :: 0
    param iPri :: 0
}

object RTA_dispatcher :: IDL {
    param iComment :: "This object cannot be deleted"
    param iIsUsed :: 1
    param iId :: 0
    param iDelUser :: "HST"
    param iDelMsg :: "This object cannot be deleted"
    param function :: @RTA_F_dispatch
    param cycles :: 0
    param calibration :: 1
    param Order :: 0
    param iPri :: 0
}

object RTA_fromHost :: HST {
    param iComment :: "Used to access LOG and STS data"
    param iIsUsed :: 1
    param iId :: 1
    param iDelUser :: "HST"
    param iDelMsg :: "This object cannot be deleted"
    param mode :: "input"
    param bufseg :: IRAM
    param bufalign :: 4
    param buf :: "<NULL>"
    param framesize :: 4
    param numframes :: 1
    param stsflg :: 0
    param notify :: @_FXN_F_nop
    param arg0 :: 0
    param arg1 :: 0
    param iDHLAvailable :: 0
}

object RTA_toHost :: HST {
    param iComment :: "Used to access LOG and STS data"
    param iIsUsed :: 1
    param iId :: 0
    param iDelUser :: "HST"
    param iDelMsg :: "This object cannot be deleted"
    param mode :: "output"
    param bufseg :: IRAM
    param bufalign :: 4
    param buf :: "<NULL>"
    param framesize :: 64
    param numframes :: 1
    param stsflg :: 0
    param notify :: @_FXN_F_nop
    param arg0 :: 0
    param arg1 :: 0
    param iDHLAvailable :: 0
}

type HWI {
    isa ObjectMgr
    prop name :: "HWI"
    prop Label :: "HWI - Hardware Interrupt Service Routine Manager"
    prop IsContainedIn :: SCH
    prop SortChildHierView :: 0
    prop GlobalIcon :: 109
    prop InstanceIcon :: 110
    prop InstanceHelpTopic :: (205)
    prop GlobalHelpTopic :: (105)
    prop dataSize :: (0 * HWI.gNumOf)
    prop localCanCreate :: (self.error("New hardware interrupt objects cannot be created"))
    prop InstancePropertyPage :: ("{B7240DE6-AA51-11cf-9BFE-0000C0AC14C7}")
    prop GlobalPropertyPage :: ("{B7240DE7-AA51-11cf-9BFE-0000C0AC14C7}")
    prop DependsOn :: "GBL,OBJ,BUF,CLK,IDL,LCK,LOG,MBX,MEM,PIP,POOL,PRD,QUE,RTDX,SEM,STS,SYS"
    prop AllocType :: (if self.ZEROTAB {"1\0,   _stubsAllocDesc,        _memSeg,        _placement"} else {if ((MEM.ENABLELOADSEG) && (MEM.VECMEMSEG != MEM.LOADVECMEMSEG)) {"2\0,       _stubsAllocDesc,        _memSeg,        _placement,
                        _vectAllocDesc,         _loadvecSeg,    _minplace"} else {"2\0,       _stubsAllocDesc,        _memSeg,        _placement,
                        _vectAllocDesc,         _vecSeg,        _minplace"}})
    prop _stubsAllocDesc :: (if ((MEM.ENABLELOADSEG) && (MEM.STUBMEMSEG != MEM.LOADSTUBMEMSEG)) {"%8t .%1L: {} load > %2s, run\0, name, _loadstubSeg"} else {"%8t .%1L: {} \0, name"})
    prop _vectAllocDesc :: (if ((MEM.ENABLELOADSEG) && (MEM.VECMEMSEG != MEM.LOADVECMEMSEG)) {"%8t .%1L_vec: {%12t\n *(.hwi_vec)%8t\n } run > %2s align = 0x400, RUN_START(%1U_A_VECS), load \0, name, _vecSeg"} else {"%8t .%1L_vec: {%12t\n *(.hwi_vec)%8t\n } align = 0x400, RUN_START(%1U_A_VECS)\0, name"})
    prop _placement :: (0x7fffffff / 2)
    prop _minplace :: 0
    prop GenLinkPrologue :: (if self.ZEROTAB {if ((MEM.ENABLELOADSEG) && (MEM.VECMEMSEG != MEM.LOADVECMEMSEG)) {"SECTIONS {%4t\n .%1L_vec: {%8t\n %1U_A_VECS = .;\n *(.hwi_vec)%4t\n }  load >  %2s, run = 0x0 %0t\n}\n\0 , name, _loadvecSeg"} else {"SECTIONS {%4t\n .%1L_vec: 0x0 {%8t\n %1U_A_VECS = .;\n *(.hwi_vec)%4t\n }%0t\n}\n\0, name"}} else {if self.GENERATE_RESET_VEC {"SECTIONS {%4t\n .%1L_reset: 0x%2x {}%0t\n}\n\0, name, resetvector"} else {""}})
    prop resetvector :: (self.RESETVECTORADDR)
    prop GenLinkEpilogue :: ("%0t_HWI_CFGDISPATCHED = HWI_CFGDISPATCHED;\n\0")
    prop localInit :: (if (RTDX.CALLBACKOBJ != nil) {self.error("HWI initialization failure.")} , RTDX.CALLBACKOBJ = HWI)
    prop enableLoadStubs :: (HWI_INT4.iLoadTrack = 1, HWI_INT5.iLoadTrack = 1, HWI_INT6.iLoadTrack = 1, HWI_INT7.iLoadTrack = 1, HWI_INT8.iLoadTrack = 1, HWI_INT9.iLoadTrack = 1, HWI_INT10.iLoadTrack = 1, HWI_INT11.iLoadTrack = 1, HWI_INT12.iLoadTrack = 1, HWI_INT13.iLoadTrack = 1, HWI_INT14.iLoadTrack = 1, HWI_INT15.iLoadTrack = 1)
    prop disableLoadStubs :: (HWI_INT4.iLoadTrack = 0, HWI_INT5.iLoadTrack = 0, HWI_INT6.iLoadTrack = 0, HWI_INT7.iLoadTrack = 0, HWI_INT8.iLoadTrack = 0, HWI_INT9.iLoadTrack = 0, HWI_INT10.iLoadTrack = 0, HWI_INT11.iLoadTrack = 0, HWI_INT12.iLoadTrack = 0, HWI_INT13.iLoadTrack = 0, HWI_INT14.iLoadTrack = 0, HWI_INT15.iLoadTrack = 0)
    prop call :: (if (RTDX.USERTDX == 0) {HWI_RESERVED1.function = @HWI_unused, HWI_RESERVED1.iUseDispatcher = 0, HWI_INT11.iReMappable = 1, HWI_INT11.function = @HWI_unused, HWI_INT11.iUseDispatcher = 0, HWI_INT11.iIntrMask = "self", HWI_INT11.client = "USER", HWI_INT12.iReMappable = 1, HWI_INT12.function = @HWI_unused, HWI_INT12.iUseDispatcher = 0, HWI_INT12.iIntrMask = "self", HWI_INT12.client = "USER"} else {HWI_RESERVED1.function = @_RTDX_Poll, HWI_RESERVED1.iUseDispatcher = 1, if (RTDX.RTDXTYPE == "HSRTDX") {HWI_INT11.iEventId = 11, HWI_INT11.iReMappable = 0, HWI_INT11.function = @_HSRTDX_xmt, HWI_INT11.iUseDispatcher = 1, HWI_INT11.iIntrMask = "bitmask", HWI_INT11.IntrMask = 0x1808, HWI_INT11.client = "RTDX", HWI_INT12.iEventId = 12, HWI_INT12.iReMappable = 0, HWI_INT12.function = @_HSRTDX_rec, HWI_INT12.iUseDispatcher = 1, HWI_INT12.iIntrMask = "bitmask", HWI_INT12.IntrMask = 0x1808, HWI_INT12.client = "RTDX"} else {if (RTDX.RTDXTYPE == "JTAG") {HWI_INT11.iEventId = 11, HWI_INT11.iReMappable = 0, HWI_INT11.function = @_HSRTDX_xmt, HWI_INT11.iUseDispatcher = 1, HWI_INT11.iIntrMask = "bitmask", HWI_INT11.IntrMask = 0x1808, HWI_INT11.client = "RTDX", HWI_INT12.iEventId = 12, HWI_INT12.iReMappable = 0, HWI_INT12.function = @_HSRTDX_rec, HWI_INT12.iUseDispatcher = 1, HWI_INT12.iIntrMask = "bitmask", HWI_INT12.IntrMask = 0x1808, HWI_INT12.client = "RTDX"} else {HWI_INT11.iReMappable = 1, HWI_INT11.function = @HWI_unused, HWI_INT11.iUseDispatcher = 0, HWI_INT11.iIntrMask = "self", HWI_INT11.client = "USER", HWI_INT12.iReMappable = 1, HWI_INT12.function = @HWI_unused, HWI_INT12.iUseDispatcher = 0, HWI_INT12.iIntrMask = "self", HWI_INT12.client = "USER"}}})
    prop _memSeg :: MEM.STUBMEMSEG
    prop _loadstubSeg :: MEM.LOADSTUBMEMSEG
    prop _linkString :: ($b = 0, scan ($a; HWI) {if ($a.monitor != "Nothing") {$b = 1} }, if ($b == 1) {"*(.hwi)"} else {"/* no HWI stubs are necessary */"})
    prop name2addr :: ($i = 0, $b = nil, scan ($a; {"Nothing", "Data Value", "Stack Pointer", "Top of SW Stack", "A0", "A1", "A2", "A3", "A4", "A5", "A6", "A7", "A8", "A9", "A10", "A11", "A12", "A13", "A14", "A15", "B0", "B1", "B2", "B3", "B4", "B5", "B6", "B7", "B8", "B9", "B10", "B11", "B12", "B13", "B14", "B15"}) {if ($b == nil) {if ($a == $1) {$b = {0, 0, 0, @GBL_stackbeg, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}[$i]} , $i++} }, if ($b == nil) {$b = 0} , $b)
    prop name2type :: ($i = 0, $b = nil, scan ($a; {"Nothing", "Data Value", "Stack Pointer", "Top of SW Stack", "A0", "A1", "A2", "A3", "A4", "A5", "A6", "A7", "A8", "A9", "A10", "A11", "A12", "A13", "A14", "A15", "B0", "B1", "B2", "B3", "B4", "B5", "B6", "B7", "B8", "B9", "B10", "B11", "B12", "B13", "B14", "B15"}) {if ($b == nil) {if ($a == $1) {if ($i < 5) {$b = {"unsigned", "signed", "unsigned", "unsigned", "unsigned"}[$i]} } , $i++} }, if ($b == nil) {$b = "unsigned"} , $b)
    prop _vecSeg :: MEM.VECMEMSEG
    prop _loadvecSeg :: MEM.LOADVECMEMSEG
    prop HWIR0_DISP :: (if (HWI_RESERVED0.iUseDispatcher == 1) {0x4} else {0})
    prop HWIR1_DISP :: (if (HWI_RESERVED1.iUseDispatcher == 1) {0x8} else {0})
    prop HWI4_DISP :: (if (HWI_INT4.iUseDispatcher == 1) {0x10} else {0})
    prop HWI5_DISP :: (if (HWI_INT5.iUseDispatcher == 1) {0x20} else {0})
    prop HWI6_DISP :: (if (HWI_INT6.iUseDispatcher == 1) {0x40} else {0})
    prop HWI7_DISP :: (if (HWI_INT7.iUseDispatcher == 1) {0x80} else {0})
    prop HWI8_DISP :: (if (HWI_INT8.iUseDispatcher == 1) {0x100} else {0})
    prop HWI9_DISP :: (if (HWI_INT9.iUseDispatcher == 1) {0x200} else {0})
    prop HWI10_DISP :: (if (HWI_INT10.iUseDispatcher == 1) {0x400} else {0})
    prop HWI11_DISP :: (if (HWI_INT11.iUseDispatcher == 1) {0x800} else {0})
    prop HWI12_DISP :: (if (HWI_INT12.iUseDispatcher == 1) {0x1000} else {0})
    prop HWI13_DISP :: (if (HWI_INT13.iUseDispatcher == 1) {0x2000} else {0})
    prop HWI14_DISP :: (if (HWI_INT14.iUseDispatcher == 1) {0x4000} else {0})
    prop HWI15_DISP :: (if (HWI_INT15.iUseDispatcher == 1) {0x8000} else {0})
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 65535 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 16 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global STUBMEMSEG :: DDR { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: MEM.codeMember($1)
        prop Label :: "Function Stub Memory"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    global ZEROTAB :: = if (6748 == 6499 || 6748 == 6747 || 6748 == 6748) {0} else {self.VECMEMSEG.base == self.RESETVECTORADDR} { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Writable :: 0
        prop Visible :: 0
    }
    global VECMEMSEG :: DDR { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop Label :: "Interrupt Service Table Memory"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
        prop MemberTest :: MEM.codeMember($1)
        prop Set :: (self.VECMEMSEG = $1, if ($1.base == 0) {self.GENERATE_RESET_VEC = 0} , "ok")
    }
    global GENERATE_RESET_VEC :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Generate RESET vector"
        prop JSName :: "RESETVECTOR"
        prop Writable :: self.ZEROTAB == 0
        prop Visible :: 1
        prop NoGen :: 0
    }
    global RESETVECTORADDR :: 8388608 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "RESET vector address"
        prop JSName :: "RESETVECTORADDR"
        prop Format :: "0x%08x"
        prop Style :: 0x02
        prop Writable :: self.GENERATE_RESET_VEC
        prop Visible :: 1
        prop NoGen :: 1
    }
    global EXT4_POLARITY :: "low-to-high" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "low-to-high,high-to-low"
        prop Label :: "External Interrupt Pin 4 Polarity"
        prop JSName :: "EXTPIN4POLARITY"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
    }
    global EXT5_POLARITY :: "low-to-high" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "low-to-high,high-to-low"
        prop Label :: "External Interrupt Pin 5 Polarity"
        prop JSName :: "EXTPIN5POLARITY"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
    }
    global EXT6_POLARITY :: "low-to-high" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "low-to-high,high-to-low"
        prop Label :: "External Interrupt Pin 6 Polarity"
        prop JSName :: "EXTPIN6POLARITY"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
    }
    global EXT7_POLARITY :: "low-to-high" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "low-to-high,high-to-low"
        prop Label :: "External Interrupt Pin 7 Polarity"
        prop JSName :: "EXTPIN7POLARITY"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
    }
    global POLARITYMASK :: = (if self.EXT4_POLARITY == "high-to-low" {1} else {0}) | (if self.EXT5_POLARITY == "high-to-low" {1} else {0}) << 1 | (if self.EXT6_POLARITY == "high-to-low" {1} else {0}) << 2 | (if self.EXT7_POLARITY == "high-to-low" {1} else {0}) << 3 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    global INTRMUX1 :: = (HWI_INT4.iEventId) | (HWI_INT5.iEventId << 8) | (HWI_INT6.iEventId << 16) | (HWI_INT7.iEventId << 24) { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x02
        prop Writable :: 0
        prop Visible :: 0
        prop NoGen :: 0
    }
    global INTRMUX2 :: = (HWI_INT8.iEventId) | (HWI_INT9.iEventId << 8) | (HWI_INT10.iEventId << 16) | (HWI_INT11.iEventId << 24) { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x02
        prop Writable :: 0
        prop Visible :: 0
        prop NoGen :: 0
    }
    global INTRMUX3 :: = (HWI_INT12.iEventId) | (HWI_INT13.iEventId << 8) | (HWI_INT14.iEventId << 16) | (HWI_INT15.iEventId << 24) { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x02
        prop Writable :: 0
        prop Visible :: 0
        prop NoGen :: 0
    }
    global ENABLE_EXC :: 1 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Enable EXC module exception processing"
        prop JSName :: "ENABLEEXC"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
        prop Set :: (if ($1 == 1) {self.ENABLE_EXC = 1, HWI_NMI.function = @_EXC_dispatch} else {self.ENABLE_EXC = 0, HWI_NMI.function = @HWI_unused}, "ok")
    }
    global CFGDISPATCHED :: = (self.HWIR0_DISP | self.HWIR1_DISP | self.HWI4_DISP | self.HWI5_DISP | self.HWI6_DISP | self.HWI7_DISP | self.HWI8_DISP | self.HWI9_DISP | self.HWI10_DISP | self.HWI11_DISP | self.HWI12_DISP | self.HWI13_DISP | self.HWI14_DISP | self.HWI15_DISP) { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "dispatched mask"
        prop Style :: 0x02
        prop Writable :: 1
        prop Visible :: 0
        prop NoGen :: 0
    }
    inst iComment :: if self.iDelUser == "USER" {"<add comments here>"} else {self.iDelMsg} { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "comment"
        prop JSName :: "comment"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "USER" {1} else {0}
        prop NoGen :: 1
    }
    inst iIsUsed :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iId :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iDelUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDelMsg :: "ok" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iSource :: Reset { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: ISRC
        prop MemberTest :: 1
        prop Label :: "interrupt source"
        prop JSName :: "interruptSource"
        prop Visible :: if (GBL.CLKTYPE == 700) {0} else {if (GBL.DSPSUBTYPE == 6499 || GBL.DSPSUBTYPE == 6747 || GBL.DSPSUBTYPE == 6748) {0} else {1}}
        prop Writable :: if (GBL.CLKTYPE == 700) {0} else {self.iReMappable}
        prop NoGen :: 1
        prop Set :: ($a = $1, if ($a == Reset) {self.error("The Reset interrupt source cannot be remapped")} else {if ($a == Non_Maskable) {self.error("The Non-Maskable interrupt source cannot be remapped")} else {if ($a == Reserved) {self.error("The Reserved interrupt source cannot be remapped")} else {if (CLK.WHICHHWI == self && $a != self.iSource && CLK.USETIMER) {self.error("This interrupt is in use by CLK, settings may be changed in the CLK Manager")} else {if ($a == CLK.WHICHHWI.iSource && CLK.USETIMER == 1) {self.error("Interrupt source is in use by CLK, settings may be changed in the CLK Manager.")} else {$a.iHwi = self, self.iSource.iHwi = HWI_UNUSED, self.iSource = $1, self.iEventId = self.iSource.iIntrSelectNum, "ok"}}}}})
    }
    inst iEventId :: = self.iSource.iIntrSelectNum { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "interrupt selection number"
        prop JSName :: "interruptSelectNumber"
        prop Style :: 0x02
        prop Visible :: if (GBL.CLKTYPE == 700) {0} else {1}
        prop Writable :: if (GBL.CLKTYPE == 700) {0} else {self.iReMappable}
        prop NoGen :: 1
        prop Set :: (if ($1 == 0 || $1 == 1 || $1 == 2 || $1 == 3) {self.function = @_ECM_dispatch, self.iUseDispatcher = 1, self.iArg = $1} else {if (self.function == @_ECM_dispatch) {self.iArg = 0x0, if (self.iUseDispatcher == 1) {self.iUseDispatcher = 0} , self.function = @HWI_unused} }, self.iEventId = $1, "ok")
    }
    inst iReMappable :: 1 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iIntrEnableMask :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x02
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst function :: @HWI_unused { 
        prop JSName :: "fxn"
        prop Visible :: 1
        prop Writable :: if ((self.function == @RESERVED) || (self.client != "USER")) {0} else {1}
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop NoGen :: 0
        prop Set :: (self.function = $1, GlobalStatus.gDirty = 1, "ok")
    }
    inst iSTSObj :: HWI_RESETSTS { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst monitor :: "Nothing" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Nothing,Data Value,Stack Pointer,Top of SW Stack,A0,A1,A2,A3,A4,A5,A6,A7,A8,A9,A10,A11,A12,A13,A14,A15,B0,B1,B2,B3,B4,B5,B6,B7,B8,B9,B10,B11,B12,B13,B14,B15"
        prop JSName :: "monitor"
        prop Visible :: 1
        prop Writable :: ((self.function != @HWI_unused && self.function != @RESERVED) && (self.iId != 0))
        prop NoGen :: 0
        prop Set :: (if ($1 != self.monitor) {$e = "ok", if ($1 == "Nothing") {if (($e = self.iSTSObj.Delete("HWI")) == "ok") {self.monitor = "Nothing", self.addr = self.name2addr(self.monitor), self.dataType = self.name2type(self.monitor)} } else {if (self.iSTSObj.iIsUsed || ($e = self.iSTSObj.Create("HWI")) == "ok") {self.monitor = $1, if (self.monitor == "Data Value") {self.addr = self.saveAddr, self.dataType = self.saveType} else {self.addr = self.name2addr(self.monitor), self.dataType = self.name2type(self.monitor)}} else {self.monitor = "Nothing"}}, $e} else {"ok"})
    }
    inst saveAddr :: 0 { 
        prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst saveType :: "signed" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst addr :: 0 { 
        prop JSName :: "addr"
        prop Visible :: 1
        prop Writable :: (if self.monitor == "Data Value" {1} else {0})
        prop NoGen :: 0
        prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
        prop Format :: if GBL.DSPTYPE == 62 {"0x%08x"} else {"0x%04x"}
        prop Set :: (self.addr = $1, self.saveAddr = $1, "ok")
    }
    inst dataType :: "signed" { 
        prop Visible :: 1
        prop Writable :: (if self.monitor == "Nothing" {0} else {1})
        prop NoGen :: 0
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "signed,unsigned"
        prop Label :: "type"
        prop JSName :: "dataType"
        prop Set :: (if (self.monitor != "Nothing") {self.dataType = $1, self.saveType = $1, "ok"} else {self.error("The monitor field must set to modify this field")})
    }
    inst operation :: "STS_add(*addr)" { 
        prop Visible :: 1
        prop Writable :: (if self.monitor == "Nothing" {0} else {1})
        prop NoGen :: 0
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop JSName :: "operation"
        prop Enum :: "STS_add(*addr),STS_delta(*addr),STS_add(-*addr),STS_delta(-*addr),STS_add(|*addr|),STS_delta(|*addr|)"
        prop Set :: (if (self.monitor != "Nothing") {self.operation = $1, "ok"} else {self.error("The monitor field must set to modify this field")})
    }
    inst client :: "USER" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    inst iUseDispatcher :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Use Dispatcher"
        prop JSName :: "useDispatcher"
        prop Visible :: 1
        prop Writable :: if (self.client == "USER") {1} else {0}
        prop NoGen :: 0
        prop TabName :: "Dispatcher"
        prop Set :: (if (($1 == 1) && (self == HWI_NMI)) {self.error("HWI dispatcher can't be used for  NMI")} else {self.iUseDispatcher = $1, "ok"})
    }
    inst iArg :: 0 { 
        prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "Arg"
        prop JSName :: "arg"
        prop Visible :: 1
        prop Writable :: if ((self.iUseDispatcher == 1) && (self.client == "USER")) {1} else {0}
        prop NoGen :: 0
        prop TabName :: "Dispatcher"
        prop Set :: (self.iArg = $1, "ok")
    }
    inst iIntrMask :: "self" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Interrupt Mask"
        prop JSName :: "interruptMask"
        prop Enum :: "all,none,self,bitmask"
        prop Visible :: 1
        prop Writable :: if (self.iUseDispatcher == 1) {1} else {0}
        prop NoGen :: 1
        prop TabName :: "Dispatcher"
        prop Set :: (if ($1 == "all") {self.IntrMask = 0xffff} else {if ($1 == "self") {self.IntrMask = 1 << self.iId} else {if ($1 == "none") {self.IntrMask = 0} }}, self.iIntrMask = $1, "ok")
    }
    inst IntrMask :: (1 << self.iId) { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04x"
        prop Style :: 0x02
        prop Label :: "Interrupt Bit Mask"
        prop JSName :: "interruptBitMask"
        prop Visible :: 1
        prop Writable :: if ((self.iUseDispatcher == 1) && (self.iIntrMask == "bitmask")) {1} else {0}
        prop NoGen :: 0
        prop TabName :: "Dispatcher"
        prop Set :: (if ($1 > 0xffff) {self.error("Invalid Number")} else {self.IntrMask = $1, "ok"})
    }
    inst iCacheControl :: 1 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Don't modify cache control"
        prop JSName :: "cacheControl"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
        prop TabName :: "Dispatcher"
        prop Set :: (if ($1 == 1) {self.iCCBitMask = 0x1} else {self.iCCBitMask = (self.iPCCBitMask | self.iDCCBitMask | self.iL2CCBitMask)}, self.iCacheControl = $1, "ok")
    }
    inst iPCCMask :: "cache enable" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "cache enable,cache freeze"
        prop Label :: "L1 Program Cache Control Mask"
        prop JSName :: "progCacheMask"
        prop Visible :: 0
        prop Writable :: if ((self.iUseDispatcher == 1) && (self.iCacheControl == 0)) {1} else {0}
        prop NoGen :: 1
        prop TabName :: "Dispatcher"
        prop Set :: (if ($1 == "cache enable") {self.iPCCBitMask = 0x0000} else {if ($1 == "cache freeze") {self.iPCCBitMask = 0x0010} }, self.iPCCMask = $1, self.iCCBitMask = self.iPCCBitMask | self.iDCCBitMask | self.iL2CCBitMask, "ok")
    }
    inst iPCCBitMask :: 0x0000 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDCCMask :: "cache enable" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "cache enable,cache freeze"
        prop Label :: "Data Cache Control Mask"
        prop JSName :: "dataCacheMask"
        prop Visible :: 0
        prop Writable :: if ((self.iUseDispatcher == 1) && (self.iCacheControl == 0)) {1} else {0}
        prop NoGen :: 1
        prop TabName :: "Dispatcher"
        prop Set :: (if ($1 == "cache enable") {self.iDCCBitMask = 0x0000} else {if ($1 == "cache freeze") {self.iDCCBitMask = 0x0002} }, self.iDCCMask = $1, self.iCCBitMask = self.iPCCBitMask | self.iDCCBitMask | self.iL2CCBitMask, "ok")
    }
    inst iDCCBitMask :: 0x0000 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iL2CCMask :: "cache enable" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "cache enable,cache freeze,cache bypass"
        prop Label :: "L2 Cache Control Mask"
        prop JSName :: "l2CacheMask"
        prop Visible :: 0
        prop Writable :: if ((self.iUseDispatcher == 1) && (self.iCacheControl == 0)) {1} else {0}
        prop NoGen :: 1
        prop TabName :: "Dispatcher"
        prop Set :: (if ($1 == "cache enable") {self.iL2CCBitMask = 0x0000} else {if ($1 == "cache freeze") {self.iL2CCBitMask = 0x0080} else {if ($1 == "cache bypass") {self.iL2CCBitMask = 0x0100} }}, self.iL2CCMask = $1, self.iCCBitMask = self.iPCCBitMask | self.iDCCBitMask | self.iL2CCBitMask, "ok")
    }
    inst iL2CCBitMask :: 0x0000 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iCCBitMask :: 1 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    inst iLoadTrack :: 0 { 
        prop Label :: "Support CPU load tracking"
        prop JSName :: "loadTrack"
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 0
    }
}

object HWI_RESET_STS :: STS {
    param iComment :: "provides statistics for the RESET ISR"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "HWI"
    param iDelMsg :: "This STS object is being used by a HWI object and cannot be deleted"
    param prev :: 0
    param format :: "%g"
    param filter :: 1
    param maxformat :: "%g"
    param sumformat :: "%g"
    param avgformat :: "%.2f"
    param unittype :: "Not time based"
    param operation :: "Nothing"
    param iA :: 1
    param iB :: 0
    param iC :: 1
    param prevhigh :: 0
    param prevlow :: 0
}

object HWI_RESET :: HWI {
    param iComment :: "defines function for the RESET ISR"
    param iIsUsed :: 1
    param iId :: 0
    param iDelUser :: "HWI"
    param iDelMsg :: "Hardware interrupt objects cannot be deleted"
    param iSource :: Reset
    param iReMappable :: 0
    param iIntrEnableMask :: 1
    param function :: @_c_int00
    param iSTSObj :: HWI_RESET_STS
    param monitor :: "Nothing"
    param saveAddr :: 0
    param saveType :: "signed"
    param addr :: 0
    param dataType :: "signed"
    param operation :: "STS_add(*addr)"
    param client :: "USER"
    param iUseDispatcher :: 0
    param iArg :: 0
    param iIntrMask :: "self"
    param IntrMask :: 1
    param iCacheControl :: 1
    param iPCCMask :: "cache enable"
    param iPCCBitMask :: 0
    param iDCCMask :: "cache enable"
    param iDCCBitMask :: 0
    param iL2CCMask :: "cache enable"
    param iL2CCBitMask :: 0
    param iCCBitMask :: 1
    param iLoadTrack :: 0
}

object HWI_NMI_STS :: STS {
    param iComment :: "provides statistics for the NMI ISR"
    param iIsUsed :: 0
    param iId :: 0
