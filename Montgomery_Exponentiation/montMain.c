#include <stdint.h>
#include <stdio.h>
#include <string.h>

#include "additionalFunctions.h"
#include "modularInverseShort.h"
#include "montMultiplication.h"
#include "montFunctions.h"

#define modLen 5
// modBits = 2048

int main(void){

/* 	uint16_t modulus[modLen] = {0x00,0x03,0x0345,0x1200,0x001};
	while(modulus[modLen-1]%2 ==0){
		divideByTwo(modulus,modLen);
	}
	uint16_t x[modLen];
	uint16_t exponent[modLen];
	uint16_t A[modLen];
	uint16_t zeros[2*(modLen+1)];
	zerosArray(zeros,2*(modLen+1)); */
	
	// uint16_t test[modLen+1] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x30};
	
	// uint16_t test2[modLen+1] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2345, 0x6f};
	
	// uint16_t testModulus[modLen+1] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11};

	// Calculate position of most significant bit of exponent //
	
/* 	uint16_t testArray[3] = {0x0000,0x0001,0x8001};
	uint16_t result = positionMSB(testArray,3);
	printf("result (MSB) = %u\n", result);
	char name[10] = "testArray";
	printArray(testArray,name,3); */
	
	// uint16_t expMSB = positionMSB(exponent,modLen);
		
/*  	mod(test,testModulus,A,modLen);
	char nameA[2] = "A";
	printArray(A,nameA,modLen); */
	
/* 	// calculate(R mod m)
	uint16_t R[modLen+1];
	zerosArray(R,modLen+1);
	R[0] = 0x0001;
	uint16_t copyR[modLen+1];
	copyArray(R,copyR,modLen+1);
	char nameR[2] = "R";
	printArray(R,nameR,modLen+1);
	mod(R,modulus,A,modLen+1,modLen);
	char nameA[2] = "A";
	printArray(A,nameA,modLen);
	char nameM[2] = "M";
	printArray(modulus,nameM,modLen);
	
	// Calculate inverse of M mod R //
	uint16_t inverse[modLen];
	modularInverseShort(modulus,R,inverse,modLen, modLen+1);
	char nameInv[8] = "inverse";
	printArray(inverse,nameInv,modLen);
	
	// Calculate (R^2 mod m);
	uint16_t Rsquare[2*(modLen+1)];
	uint16_t RsquareMod[modLen];
	//montMul(R,R,modulus,inverse,Rsquare,modLen+1);
	squareProduct(R,Rsquare,modLen+1);
	mod(Rsquare,modulus,RsquareMod,2*(modLen+1),modLen);
	char nameRsquare[8] = "RSquare";
	printArray(Rsquare,nameRsquare,2*(modLen+1));
	char nameRSquareMod[11] = "RSquareMod";
	printArray(RsquareMod,nameRSquareMod,modLen); */
	
/* 	uint16_t binaryArray[52] = {
	0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 1, 0, 0, 1, 1, 1,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 
	1,1,0,1};
	uint16_t hexArray[4];
	from2to16(binaryArray,hexArray,52);
	char nameArray[9] = "hexArray";
	printArray(hexArray,nameArray,4); */
	
/* 	squareProduct(test,zeros,modLen+1);
	char name[6] = "zeros";
	printArray(zeros,name,2*(modLen+1)); */


 	uint16_t c[5] = {0x00, 0x00, 0x00, 0x245, 0x03};
	uint16_t d[5] = {0x00, 0x00, 0x00, 0x034, 0x02};
	uint16_t modulus[4] = { 0x00, 0x00, 0x02, 0x00};
	uint16_t k[3] = { 0x00, 0x14, 0x6700};
	uint16_t l[3] = { 0x00, 0x00, 0x5645};
	uint16_t m[3] = { 0x00, 0x06, 0x7415};
	uint16_t e[4] = { 0x00, 0x00, 0x00, 0x03};
	uint16_t f[5] = {0x00, 0x00, 0x00, 0X0001, 0x9259};
	uint16_t g[5]= { 0x00, 0x00, 0x00, 0X00, 0x04};
	// uint16_t resultCD[10] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
	// uint16_t resultInv[5];
	// zerosArray(resultInv,5);
	// modularInverseShort(e,f,resultInv,4,5);
	// char nameInv[10] = "resultInv";
	// printArray(resultInv,nameInv,5);
	// uint16_t resultDivision[3];
	// uint16_t remainder[3];
	// division(k,m,resultDivision,remainder,3,3);
	// char nameDivision[15] = "resultDivision";
	// printArray(resultDivision,nameDivision,3);
	// char nameRemainder[16] = "resultRemainder";
	// printArray(remainder,nameRemainder,3);
	uint16_t result[20];
	modMult(k,l,m,result,3,3,3);
	char nameResult[7] = "result";
	printArray(result,nameResult,20);
	
/* 	mod(c,modulus,resultC,5,4);
	char nameResult[7] = "result";
	printArray(resultC,nameResult,4);
	
	subtractionShort(c,d,c,5);
	char nameC[2] = "c";
	printArray(c,nameC,5);
	
	multiplication(c,d,result,5,5);
	char nameResult[7] = "result";
	printArray(result,nameResult,10);  */
	
	
}
